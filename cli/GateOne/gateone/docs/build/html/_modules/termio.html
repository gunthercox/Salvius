

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>termio &mdash; Gate One 1.1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/ansi.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.png"/>
    <link rel="top" title="Gate One 1.1.0 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">Gate One Documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for termio</h1><div class="highlight"><pre>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="c">#</span>
<span class="c">#       Copyright 2011 Liftoff Software Corporation (http://liftoffsoftware.com)</span>
<span class="c">#</span>
<span class="c"># NOTE:  Commercial licenses for this software are available!</span>
<span class="c">#</span>

<span class="c"># TODO: See if we can spin off termio.py into its own little program that sits between Gate One and ssh_connect.py.  That way we can take advantage of multiple cores/processors (for terminal-to-HTML processing).  There&#39;s no reason why we can&#39;t write something that does what dtach does.  Just need to redirect the fd of self.cmd to a unix domain socket and os.setsid() somewhere after forking (twice maybe?).</span>
<span class="c"># TODO: Make the environment variables used before launching self.cmd configurable</span>

<span class="c"># Meta</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s">&#39;1.1&#39;</span>
<span class="n">__license__</span> <span class="o">=</span> <span class="s">&quot;AGPLv3 or Proprietary (see LICENSE.txt)&quot;</span>
<span class="n">__version_info__</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">__author__</span> <span class="o">=</span> <span class="s">&#39;Dan McDougall &lt;daniel.mcdougall@liftoffsoftware.com&gt;&#39;</span>

<span class="n">__doc__</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">About termio</span>
<span class="s">============</span>
<span class="s">This module provides a Multiplex class that can perform the following:</span>

<span class="s"> * Fork a child process that opens a given terminal program.</span>
<span class="s"> * Read and write data to and from the child process (synchronously or asynchronously).</span>
<span class="s"> * Examine the output of the child process in real-time and perform actions (also asynchronously!) based on what is &quot;expected&quot; (aka non-blocking, pexpect-like functionality).</span>
<span class="s"> * Log the output of the child process to a file and/or syslog.</span>

<span class="s">The Multiplex class was built for asynchronous use in conjunction with a running</span>
<span class="s">:class:`tornado.ioloop.IOLoop` instance but it can be used in a synchronous</span>
<span class="s">(blocking) manner as well.  Synchronous use of this module is most likely to be</span>
<span class="s">useful in an interactive Python session but if blocking doesn&#39;t matter for your</span>
<span class="s">program please see the section titled, &quot;Blocking&quot; for tips &amp; tricks.</span>

<span class="s">Here&#39;s an example instantiating a Multiplex class::</span>

<span class="s">    multiplexer = termio.Multiplex(</span>
<span class="s">        &#39;nethack&#39;,</span>
<span class="s">        log_path=&#39;/var/log/myapp&#39;,</span>
<span class="s">        user=&#39;bsmith@CORP&#39;,</span>
<span class="s">        term_id=1,</span>
<span class="s">        syslog=True</span>
<span class="s">    )</span>

<span class="s">.. note:: Support for event loops other than Tornado is in the works!</span>

<span class="s">Then *multiplexer* can create and launch a new controlling terminal (tty)</span>
<span class="s">running the given command (e.g. &#39;nethack&#39;)::</span>

<span class="s">    env = {</span>
<span class="s">        &#39;PATH&#39;: os.environ[&#39;PATH&#39;],</span>
<span class="s">        &#39;MYVAR&#39;: &#39;foo&#39;</span>
<span class="s">    }</span>
<span class="s">    fd = multiplexer.spawn(80, 24, env=env)</span>
<span class="s">    # The fd is returned from spawn() in case you want more low-level control.</span>

<span class="s">Asynchronous input and output from the controlled program is handled via IOLoop.</span>
<span class="s">It will automatically write all output from the terminal program to an instance</span>
<span class="s">of self.terminal_emulator (which defaults to Gate One&#39;s `terminal.Terminal`).</span>
<span class="s">So if you want to perform an action whenever the running terminal application</span>
<span class="s">has output (like, say, sending a message to a client) you&#39;ll need to attach a</span>
<span class="s">callback::</span>

<span class="s">    def screen_update():</span>
<span class="s">        &#39;Called when new output is ready to send to the client&#39;</span>
<span class="s">        output = multiplexer.dump_html()</span>
<span class="s">        socket_or_something.write(output)</span>
<span class="s">    multiplexer.callbacks[multiplexer.CALLBACK_UPDATE] = screen_update</span>

<span class="s">In this example, `screen_update()` will `write()` the output of</span>
<span class="s">`multiplexer.dump_html()` to *socket_or_something* whenever the terminal program</span>
<span class="s">has some sort of output.  You can also make calls directly to the terminal</span>
<span class="s">emulator (if you&#39;re using a custom one)::</span>

<span class="s">    def screen_update():</span>
<span class="s">        output = multiplexer.term.my_custom_func()</span>
<span class="s">        whatever.write(output)</span>

<span class="s">Writing characters to the controlled terminal application is pretty</span>
<span class="s">straightforward::</span>

<span class="s">    multiplexer.write(u&#39;some text&#39;)</span>

<span class="s">Typically you&#39;d pass in keystrokes or commands from your application to the</span>
<span class="s">underlying program this way and the screen/terminal emulator would get updated</span>
<span class="s">automatically.  If using Gate One&#39;s `terminal.Terminal()` you can also attach</span>
<span class="s">callbacks to perform further actions when more specific situations are</span>
<span class="s">encountered (e.g. when the window title is set via its respective escape</span>
<span class="s">sequence)::</span>

<span class="s">    def set_title():</span>
<span class="s">        &#39;Hypothetical title-setting function&#39;</span>
<span class="s">        print(&quot;Window title was just set to: </span><span class="si">%s</span><span class="s">&quot; % multiplexer.term.title)</span>
<span class="s">    multiplexer.term.callbacks[multiplexer.CALLBACK_TITLE] = set_title</span>

<span class="s">Module Functions and Classes</span>
<span class="s">============================</span>
<span class="s">&quot;&quot;&quot;</span>

<span class="c"># Stdlib imports</span>
<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">struct</span><span class="o">,</span> <span class="nn">io</span><span class="o">,</span> <span class="nn">gzip</span><span class="o">,</span> <span class="nn">re</span><span class="o">,</span> <span class="nn">logging</span><span class="o">,</span> <span class="nn">signal</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">timedelta</span><span class="p">,</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">izip</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span>
<span class="kn">from</span> <span class="nn">json</span> <span class="kn">import</span> <span class="n">loads</span> <span class="k">as</span> <span class="n">json_decode</span>
<span class="kn">from</span> <span class="nn">json</span> <span class="kn">import</span> <span class="n">dumps</span> <span class="k">as</span> <span class="n">json_encode</span>

<span class="c"># Inernationalization support</span>
<span class="kn">import</span> <span class="nn">gettext</span>
<span class="n">gettext</span><span class="o">.</span><span class="n">install</span><span class="p">(</span><span class="s">&#39;termio&#39;</span><span class="p">)</span>

<span class="c"># Globals</span>
<span class="n">SEPARATOR</span> <span class="o">=</span> <span class="s">u&quot;</span><span class="se">\U000f0f0f</span><span class="s">&quot;</span> <span class="c"># The character used to separate frames in the log</span>
<span class="c"># NOTE: That unicode character was carefully selected from only the finest</span>
<span class="c"># of the PUA.  I hereby dub thee, &quot;U+F0F0F0, The Separator.&quot;</span>
<span class="n">CALLBACK_THREAD</span> <span class="o">=</span> <span class="bp">None</span> <span class="c"># Used by add_callback()</span>
<span class="n">POSIX</span> <span class="o">=</span> <span class="s">&#39;posix&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">builtin_module_names</span>
<span class="n">MACOS</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">uname</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;Darwin&#39;</span>
<span class="c"># Matches Gate One&#39;s special optional escape sequence (ssh plugin only)</span>
<span class="n">RE_OPT_SSH_SEQ</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
    <span class="s">r&#39;.*\x1b\]_\;(ssh\|.+?)(\x07|\x1b</span><span class="se">\\</span><span class="s">)&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="o">|</span><span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>
<span class="c"># Matches an xterm title sequence</span>
<span class="n">RE_TITLE_SEQ</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
    <span class="s">r&#39;.*\x1b\][0-2]\;(.+?)(\x07|\x1b</span><span class="se">\\</span><span class="s">)&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="o">|</span><span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>

<span class="c"># Helper functions</span>
<div class="viewcode-block" id="debug_expect"><a class="viewcode-back" href="../Developer/termio.html#termio.debug_expect">[docs]</a><span class="k">def</span> <span class="nf">debug_expect</span><span class="p">(</span><span class="n">m_instance</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method is used by :meth:`BaseMultiplex.expect` if :attr:`self.debug` is</span>
<span class="sd">    True.  It facilitates easy debugging of regular expressions.  It will print</span>
<span class="sd">    out precisely what was matched and where.</span>

<span class="sd">    .. note::  This function only works with post-process patterns.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> was matched...&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">match</span><span class="p">))</span>
    <span class="n">out</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">m_instance</span><span class="o">.</span><span class="n">dump</span><span class="p">():</span>
        <span class="n">match_obj</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match_obj</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="s">&quot;---&gt;</span><span class="si">%s</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="s">&quot;    </span><span class="si">%s</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="retrieve_first_frame"><a class="viewcode-back" href="../Developer/termio.html#termio.retrieve_first_frame">[docs]</a><span class="k">def</span> <span class="nf">retrieve_first_frame</span><span class="p">(</span><span class="n">golog_path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves the first frame from the given *golog_path*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">found_first_frame</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">frame</span> <span class="o">=</span> <span class="n">b</span><span class="s">&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">golog_path</span><span class="p">)</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">found_first_frame</span><span class="p">:</span>
        <span class="n">frame</span> <span class="o">+=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c"># One byte at a time</span>
        <span class="k">if</span> <span class="n">frame</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">&#39;UTF-8&#39;</span><span class="p">,</span> <span class="s">&quot;ignore&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">SEPARATOR</span><span class="p">):</span>
            <span class="c"># That&#39;s it; wrap this up</span>
            <span class="n">found_first_frame</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">&#39;UTF-8&#39;</span><span class="p">,</span> <span class="s">&quot;ignore&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="n">SEPARATOR</span><span class="p">),</span> <span class="n">distance</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="retrieve_last_frame"><a class="viewcode-back" href="../Developer/termio.html#termio.retrieve_last_frame">[docs]</a><span class="k">def</span> <span class="nf">retrieve_last_frame</span><span class="p">(</span><span class="n">golog_path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves the last frame from the given *golog_path*.  It does this by</span>
<span class="sd">    iterating over the log in reverse.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">encoded_separator</span> <span class="o">=</span> <span class="n">SEPARATOR</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&#39;UTF-8&#39;</span><span class="p">)</span>
    <span class="n">golog</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">golog_path</span><span class="p">)</span>
    <span class="n">chunk_size</span> <span class="o">=</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">128</span>
    <span class="c"># Seek to the end of the file (gzip objects don&#39;t support negative seeking)</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">chunk_size</span>
    <span class="n">prev_tell</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">while</span> <span class="n">golog</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span> <span class="o">!=</span> <span class="n">prev_tell</span><span class="p">:</span>
        <span class="n">prev_tell</span> <span class="o">=</span> <span class="n">golog</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">golog</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
            <span class="k">return</span> <span class="c"># Something wrong with the file</span>
        <span class="n">distance</span> <span class="o">+=</span> <span class="n">distance</span>
    <span class="c"># Now that we&#39;re at the end, go back a bit and split from there</span>
    <span class="n">golog</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">golog</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span> <span class="o">-</span> <span class="n">chunk_size</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">end_frames</span> <span class="o">=</span> <span class="n">golog</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">encoded_separator</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_frames</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c"># Very last item will be empty</span>
        <span class="k">return</span> <span class="n">end_frames</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">&#39;UTF-8&#39;</span><span class="p">,</span> <span class="s">&#39;ignore&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># Just a single frame here, return it as-is</span>
        <span class="k">return</span> <span class="n">end_frames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">&#39;UTF-8&#39;</span><span class="p">,</span> <span class="s">&#39;ignore&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="get_or_update_metadata"><a class="viewcode-back" href="../Developer/termio.html#termio.get_or_update_metadata">[docs]</a><span class="k">def</span> <span class="nf">get_or_update_metadata</span><span class="p">(</span><span class="n">golog_path</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">force_update</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves or creates/updates the metadata inside of *golog_path*.</span>

<span class="sd">    If *force_update* the metadata inside the golog will be updated even if it</span>
<span class="sd">    already exists.</span>

<span class="sd">    .. note::  All logs will need &quot;fixing&quot; the first time they&#39;re enumerated like this since they won&#39;t have an end_date.  Fortunately we only need to do this once per golog.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&#39;get_or_update_metadata(</span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">golog_path</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">force_update</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="n">golog_path</span><span class="p">):</span> <span class="c"># 0 bytes</span>
        <span class="k">return</span> <span class="c"># Nothing to do</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">first_frame</span><span class="p">,</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">retrieve_first_frame</span><span class="p">(</span><span class="n">golog_path</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
        <span class="c"># Something wrong with the log...  Probably still being written to</span>
        <span class="k">return</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">first_frame</span><span class="p">[</span><span class="mi">14</span><span class="p">:]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;{&#39;</span><span class="p">):</span>
        <span class="c"># This is JSON, capture existing metadata</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">json_decode</span><span class="p">(</span><span class="n">first_frame</span><span class="p">[</span><span class="mi">14</span><span class="p">:])</span>
        <span class="c"># end_date gets added by this function</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">force_update</span> <span class="ow">and</span> <span class="s">&#39;end_date&#39;</span> <span class="ow">in</span> <span class="n">metadata</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">metadata</span> <span class="c"># All done</span>
    <span class="c"># &#39;\xf3\xb0\xbc\x8f&#39; &lt;--UTF-8 encoded SEPARATOR (for reference)</span>
    <span class="n">encoded_separator</span> <span class="o">=</span> <span class="n">SEPARATOR</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&#39;UTF-8&#39;</span><span class="p">)</span>
    <span class="n">golog</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">golog_path</span><span class="p">)</span>
    <span class="c"># Loop over the file in big chunks (which is faster than read() by an order</span>
    <span class="c"># of magnitude)</span>
    <span class="n">chunk_size</span> <span class="o">=</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">128</span> <span class="c"># 128k should be enough for a 100x300 terminal full</span>
    <span class="c"># of 4-byte unicode characters. That would be one BIG frame (i.e. unlikely).</span>
    <span class="n">log_data</span> <span class="o">=</span> <span class="n">b</span><span class="s">&#39;&#39;</span>
    <span class="n">total_frames</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">max_data</span> <span class="o">=</span> <span class="n">chunk_size</span> <span class="o">*</span> <span class="mi">10</span> <span class="c"># Hopefully this is enough to capture a title</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">log_data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">max_data</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">chunk</span> <span class="o">=</span> <span class="n">golog</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">chunk_size</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
            <span class="k">return</span> <span class="c"># Something wrong with the file</span>
        <span class="n">total_frames</span> <span class="o">+=</span> <span class="n">chunk</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">encoded_separator</span><span class="p">)</span>
        <span class="n">log_data</span> <span class="o">+=</span> <span class="n">chunk</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">chunk_size</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="c"># Remove the trailing incomplete frame</span>
    <span class="n">log_data</span> <span class="o">=</span> <span class="n">encoded_separator</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">log_data</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">encoded_separator</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">log_data</span> <span class="o">=</span> <span class="n">log_data</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">&#39;UTF-8&#39;</span><span class="p">,</span> <span class="s">&#39;ignore&#39;</span><span class="p">)</span>
    <span class="n">start_date</span> <span class="o">=</span> <span class="n">first_frame</span><span class="p">[:</span><span class="mi">13</span><span class="p">]</span> <span class="c"># Getting the start date is easy</span>
    <span class="n">last_frame</span> <span class="o">=</span> <span class="n">retrieve_last_frame</span><span class="p">(</span><span class="n">golog_path</span><span class="p">)</span> <span class="c"># This takes some work</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">last_frame</span><span class="p">:</span>
        <span class="k">return</span> <span class="c"># Something wrong with log</span>
    <span class="n">end_date</span> <span class="o">=</span> <span class="n">last_frame</span><span class="p">[:</span><span class="mi">13</span><span class="p">]</span>
    <span class="n">version</span> <span class="o">=</span> <span class="s">u&quot;1.0&quot;</span>
    <span class="n">connect_string</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="kn">from</span> <span class="nn">gateone</span> <span class="kn">import</span> <span class="n">PLUGINS</span>
    <span class="k">if</span> <span class="s">&#39;ssh&#39;</span> <span class="ow">in</span> <span class="n">PLUGINS</span><span class="p">[</span><span class="s">&#39;py&#39;</span><span class="p">]:</span>
        <span class="c"># Try to find the host that was connected to by looking for the SSH</span>
        <span class="c"># plugin&#39;s special optional escape sequence.  It looks like this:</span>
        <span class="c">#   &quot;\x1b]_;ssh|%s@%s:%s\007&quot;</span>
        <span class="n">match_obj</span> <span class="o">=</span> <span class="n">RE_OPT_SSH_SEQ</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">log_data</span><span class="p">[:(</span><span class="n">chunk_size</span><span class="o">*</span><span class="mi">10</span><span class="p">)])</span>
        <span class="k">if</span> <span class="n">match_obj</span><span class="p">:</span>
            <span class="n">connect_string</span> <span class="o">=</span> <span class="n">match_obj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;|&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">connect_string</span><span class="p">:</span>
        <span class="c"># Try guessing it by looking for a title escape sequence</span>
        <span class="n">match_obj</span> <span class="o">=</span> <span class="n">RE_TITLE_SEQ</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">log_data</span><span class="p">[:(</span><span class="n">chunk_size</span><span class="o">*</span><span class="mi">10</span><span class="p">)])</span>
        <span class="k">if</span> <span class="n">match_obj</span><span class="p">:</span>
            <span class="c"># The split() here is an attempt to remove the tail end of</span>
            <span class="c"># titles like this:  &#39;someuser@somehost: ~&#39;</span>
            <span class="n">connect_string</span> <span class="o">=</span> <span class="n">match_obj</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="c"># TODO: Add some hooks here for plugins to add their own metadata</span>
    <span class="n">metadata</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
        <span class="s">u&#39;user&#39;</span><span class="p">:</span> <span class="n">user</span><span class="p">,</span>
        <span class="s">u&#39;start_date&#39;</span><span class="p">:</span> <span class="n">start_date</span><span class="p">,</span>
        <span class="s">u&#39;end_date&#39;</span><span class="p">:</span> <span class="n">end_date</span><span class="p">,</span>
        <span class="s">u&#39;frames&#39;</span><span class="p">:</span> <span class="n">total_frames</span><span class="p">,</span>
        <span class="s">u&#39;version&#39;</span><span class="p">:</span> <span class="n">version</span><span class="p">,</span>
        <span class="s">u&#39;connect_string&#39;</span><span class="p">:</span> <span class="n">connect_string</span><span class="p">,</span>
        <span class="s">u&#39;filename&#39;</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">golog_path</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="p">})</span>
    <span class="c"># Make a *new* first_frame</span>
    <span class="n">first_frame</span> <span class="o">=</span> <span class="s">u&quot;</span><span class="si">%s</span><span class="s">:&quot;</span> <span class="o">%</span> <span class="n">start_date</span>
    <span class="n">first_frame</span> <span class="o">+=</span> <span class="n">json_encode</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span> <span class="o">+</span> <span class="n">SEPARATOR</span>
    <span class="n">first_frame</span> <span class="o">=</span> <span class="n">first_frame</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&#39;UTF-8&#39;</span><span class="p">)</span>
    <span class="c"># Replace the first frame and re-save the log</span>
    <span class="n">temp_path</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">.tmp&quot;</span> <span class="o">%</span> <span class="n">golog_path</span>
    <span class="n">golog</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">golog_path</span><span class="p">)</span> <span class="c"># Re-open</span>
    <span class="n">new_golog</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">temp_path</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
    <span class="n">new_golog</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">first_frame</span><span class="p">)</span>
    <span class="c"># Now write out the rest of it</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">chunk</span> <span class="o">=</span> <span class="n">golog</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">chunk_size</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
            <span class="k">return</span> <span class="c"># Something wrong with the file</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">chunk</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;{&quot;</span><span class="p">:</span> <span class="c"># Old/incomplete metadata</span>
                <span class="c"># Need to keep reading until the next frame</span>
                <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">chunk</span> <span class="o">+=</span> <span class="n">golog</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">chunk_size</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
                        <span class="k">return</span> <span class="c"># Something wrong with the file</span>
                    <span class="k">if</span> <span class="n">encoded_separator</span> <span class="ow">in</span> <span class="n">chunk</span><span class="p">:</span>
                        <span class="c"># This removes the first frame:</span>
                        <span class="n">chunk</span> <span class="o">=</span> <span class="n">encoded_separator</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                            <span class="n">chunk</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">encoded_separator</span><span class="p">)[</span><span class="mi">1</span><span class="p">:])</span>
                        <span class="k">break</span>
        <span class="n">new_golog</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">chunk_size</span><span class="p">:</span>
            <span class="k">break</span> <span class="c"># Everything must come to an end</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c"># Overwrite the old log</span>
    <span class="kn">import</span> <span class="nn">shutil</span>
    <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">temp_path</span><span class="p">,</span> <span class="n">golog_path</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">metadata</span>

<span class="c"># Exceptions</span></div>
<div class="viewcode-block" id="Timeout"><a class="viewcode-back" href="../Developer/termio.html#termio.Timeout">[docs]</a><span class="k">class</span> <span class="nc">Timeout</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Used by :meth:`BaseMultiplex.expect` and :meth:`BaseMultiplex.await`;</span>
<span class="sd">    called when a timeout is reached.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>
</div>
<div class="viewcode-block" id="ProgramTerminated"><a class="viewcode-back" href="../Developer/termio.html#termio.ProgramTerminated">[docs]</a><span class="k">class</span> <span class="nc">ProgramTerminated</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Called when we try to write to a process that&#39;s no longer running.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="c"># Classes</span></div>
<div class="viewcode-block" id="Pattern"><a class="viewcode-back" href="../Developer/termio.html#termio.Pattern">[docs]</a><span class="k">class</span> <span class="nc">Pattern</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Used by :meth:`BaseMultiplex.expect`, an object to store patterns</span>
<span class="sd">    (regular expressions) and their associated properties.</span>

<span class="sd">    .. note:: The variable *m_instance* is used below to mean the current instance of BaseMultiplex (or a subclass thereof).</span>

<span class="sd">    :pattern: A regular expression or iterable of regular expressions that will be checked against the output stream.</span>

<span class="sd">    :callback: A function that will be called when the pattern is matched.  Callbacks are called like so:</span>

<span class="sd">        &gt;&gt;&gt; callback(m_instance, matched_string)</span>

<span class="sd">        .. tip:: If you provide a string instead of a function for your *callback* it will automatically be converted into a function that writes the string to the child process.  Example::</span>

<span class="sd">            &gt;&gt;&gt; p = Pattern(&#39;(?i)password:&#39;, &#39;mypassword\\n&#39;)</span>

<span class="sd">    :optional: Indicates that this pattern is optional.  Meaning that it isn&#39;t required to match before the next pattern in :attr:`BaseMultiplex._patterns` is checked.</span>

<span class="sd">    :sticky: Indicates that the pattern will not time out and won&#39;t be automatically removed from self._patterns when it is matched.</span>

<span class="sd">    :errorback: A function to call in the event of a timeout or if an exception is encountered.  Errorback functions are called like so:</span>

<span class="sd">        &gt;&gt;&gt; errorback(m_instance)</span>

<span class="sd">    :preprocess: Indicates that this pattern is to be checked against the incoming stream before it is processed by the terminal emulator.  Useful if you need to match non-printable characters like control codes and escape sequences.</span>

<span class="sd">    :timeout: A :obj:`datetime.timedelta` object indicating how long we should wait before calling :meth:`errorback`.</span>

<span class="sd">    :created: A :obj:`datetime.datetime` object that gets set when the Pattern is instantiated by :meth:`BaseMultiplex.expect`.  It is used to determine if and when a timeout has been reached.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span>
            <span class="n">optional</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
            <span class="n">sticky</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
            <span class="n">errorback</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">preprocess</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
            <span class="n">timeout</span><span class="o">=</span><span class="mi">30</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="n">pattern</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">callback</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">unicode</span><span class="p">)):</span>
            <span class="c"># Convert the string to a write() call</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">callback</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">m</span><span class="p">,</span> <span class="n">match</span><span class="p">:</span> <span class="n">m</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">unicode</span><span class="p">(</span><span class="n">callback</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">callback</span> <span class="o">=</span> <span class="n">callback</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errorback</span> <span class="o">=</span> <span class="n">errorback</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optional</span> <span class="o">=</span> <span class="n">optional</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sticky</span> <span class="o">=</span> <span class="n">sticky</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preprocess</span> <span class="o">=</span> <span class="n">preprocess</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">timeout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">created</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseMultiplex"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex">[docs]</a><span class="k">class</span> <span class="nc">BaseMultiplex</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A base class that all Multiplex types will inherit from.</span>

<span class="sd">    :cmd: *string* - The command to execute when calling :meth:`spawn`.</span>
<span class="sd">    :terminal_emulator: *terminal.Terminal or similar* - The terminal emulator to write to when capturing the incoming output stream from *cmd*.</span>
<span class="sd">    :log_path: *string* - The absolute path to the log file where the output from *cmd* will be saved.</span>
<span class="sd">    :term_id: *string* - The terminal identifier to associated with this instance (only used in the logs to identify terminals).</span>
<span class="sd">    :syslog: *boolean* - Whether or not the session should be logged using the local syslog daemon.</span>
<span class="sd">    :syslog_host: *string* - An optional syslog host to send session log information to (this is independent of the *syslog* option above--it does not require a syslog daemon be present on the host running Gate One).</span>
<span class="sd">    :syslog_facility: *integer* - The syslog facility to use when logging messages.  All possible facilities can be found in `utils.FACILITIES` (if you need a reference other than the syslog module).</span>
<span class="sd">    :debug: *boolean* - Used by the `expect` methods...  If set, extra debugging information will be output whenever a regular expression is matched.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CALLBACK_UPDATE</span> <span class="o">=</span> <span class="mi">1</span> <span class="c"># Screen update</span>
    <span class="n">CALLBACK_EXIT</span> <span class="o">=</span> <span class="mi">2</span>   <span class="c"># When the underlying program exits</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">cmd</span><span class="p">,</span>
            <span class="n">terminal_emulator</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="c"># Defaults to Gate One&#39;s terminal.Terminal</span>
            <span class="n">log_path</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">user</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="c"># Only used by log output (to differentiate who&#39;s who)</span>
            <span class="n">term_id</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="c"># Also only for syslog output for the same reason</span>
            <span class="n">syslog</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
            <span class="n">syslog_host</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">syslog_facility</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="n">debug</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exitfunc</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">cmd</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">terminal_emulator</span><span class="p">:</span>
            <span class="c"># Why do this?  So you could use/write your own specialty emulator.</span>
            <span class="c"># Whatever you use it just has to accept &#39;rows&#39; and &#39;cols&#39; as</span>
            <span class="c"># keyword arguments in __init__()</span>
            <span class="kn">from</span> <span class="nn">terminal</span> <span class="kn">import</span> <span class="n">Terminal</span> <span class="c"># Dynamic import to cut down on waste</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">terminal_emulator</span> <span class="o">=</span> <span class="n">Terminal</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">terminal_emulator</span> <span class="o">=</span> <span class="n">terminal_emulator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_path</span> <span class="o">=</span> <span class="n">log_path</span> <span class="c"># Logs of the terminal output wind up here</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="bp">None</span> <span class="c"># Just a placeholder until it is opened</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">syslog</span> <span class="o">=</span> <span class="n">syslog</span> <span class="c"># See &quot;if self.syslog:&quot; below</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_alive</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratelimiter_engaged</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">capture_ratelimiter</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctrl_c_pressed</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">capturing_timeout</span> <span class="o">=</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">=</span> <span class="mi">24</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="mi">80</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c"># Means &quot;no pid yet&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">started</span> <span class="o">=</span> <span class="s">&quot;Never&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_patterns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_handling_match</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="c"># Setup our callbacks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span> <span class="o">=</span> <span class="p">{</span> <span class="c"># Defaults do nothing which saves some conditionals</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">CALLBACK_UPDATE</span><span class="p">:</span> <span class="p">{},</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">CALLBACK_EXIT</span><span class="p">:</span> <span class="p">{},</span>
        <span class="p">}</span>
        <span class="c"># Configure syslog logging</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">user</span> <span class="o">=</span> <span class="n">user</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">term_id</span> <span class="o">=</span> <span class="n">term_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">syslog_host</span> <span class="o">=</span> <span class="n">syslog_host</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">syslog_buffer</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">syslog</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">syslog_host</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">syslog</span>
            <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">_</span><span class="p">(</span>
                    <span class="s">&quot;The syslog module is required to log terminal sessions to &quot;</span>
                    <span class="s">&quot;syslog if no syslog_host is set.  The syslog module is not&quot;</span>
                    <span class="s">&quot; required if you want to send syslog messages to a remote &quot;</span>
                    <span class="s">&quot;syslog server but for this to work you must set the &quot;</span>
                    <span class="s">&quot;syslog_host variable either via the command-line switch or&quot;</span>
                    <span class="s">&quot; in your server.conf.&quot;</span><span class="p">))</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">syslog_facility</span><span class="p">:</span>
                <span class="n">syslog_facility</span> <span class="o">=</span> <span class="n">syslog</span><span class="o">.</span><span class="n">LOG_DAEMON</span>
            <span class="n">syslog_facility</span> <span class="o">=</span> <span class="n">syslog_facility</span>
            <span class="c"># Sets up syslog messages to show up like this:</span>
            <span class="c">#   Sep 28 19:45:02 &lt;hostname&gt; gateone: &lt;log message&gt;</span>
            <span class="n">syslog</span><span class="o">.</span><span class="n">openlog</span><span class="p">(</span><span class="s">&#39;gateone&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">syslog_facility</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns self.__str__()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s">&quot;&lt;</span><span class="si">%s</span><span class="s">&gt;&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__str__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a string representation of this Multiplex instance and the</span>
<span class="sd">        current state of things.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">started</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">started</span>
        <span class="k">if</span> <span class="n">started</span> <span class="o">!=</span> <span class="s">&quot;Never&quot;</span><span class="p">:</span>
            <span class="n">started</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">started</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s">&quot;</span><span class="si">%s</span><span class="s">.</span><span class="si">%s</span><span class="s">:  &quot;</span>
            <span class="s">&quot;term_id: </span><span class="si">%s</span><span class="s">, &quot;</span>
            <span class="s">&quot;alive: </span><span class="si">%s</span><span class="s">, &quot;</span>
            <span class="s">&quot;command: </span><span class="si">%s</span><span class="s">, &quot;</span>
            <span class="s">&quot;started: </span><span class="si">%s</span><span class="s">&quot;</span>
            <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__module__</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">term_id</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_alive</span><span class="p">,</span>
                <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cmd</span><span class="p">),</span>
                <span class="n">started</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

<div class="viewcode-block" id="BaseMultiplex.add_callback"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.add_callback">[docs]</a>    <span class="k">def</span> <span class="nf">add_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attaches the given *callback* to the given *event*.  If given,</span>
<span class="sd">        *identifier* can be used to reference this callback leter (e.g. when you</span>
<span class="sd">        want to remove it).  Otherwise an identifier will be generated</span>
<span class="sd">        automatically.  If the given *identifier* is already attached to a</span>
<span class="sd">        callback at the given event, that callback will be replaced with</span>
<span class="sd">        *callback*.</span>

<span class="sd">        *event* - The numeric ID of the event you&#39;re attaching *callback* to (e.g. Multiplex.CALLBACK_UPDATE).</span>
<span class="sd">        *callback* - The function you&#39;re attaching to the *event*.</span>
<span class="sd">        *identifier* - A string or number to be used as a reference point should you wish to remove or update this callback later.</span>

<span class="sd">        Returns the identifier of the callback.  to Example:</span>

<span class="sd">            &gt;&gt;&gt; m = Multiplex()</span>
<span class="sd">            &gt;&gt;&gt; def somefunc(): pass</span>
<span class="sd">            &gt;&gt;&gt; id = &quot;myref&quot;</span>
<span class="sd">            &gt;&gt;&gt; ref = m.add_callback(m.CALLBACK_UPDATE, somefunc, id)</span>

<span class="sd">        .. note:: This allows the controlling program to have multiple callbacks for the same event.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">identifier</span><span class="p">:</span>
            <span class="n">identifier</span> <span class="o">=</span> <span class="n">callback</span><span class="o">.</span><span class="n">__hash__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">[</span><span class="n">event</span><span class="p">][</span><span class="n">identifier</span><span class="p">]</span> <span class="o">=</span> <span class="n">callback</span>
        <span class="k">return</span> <span class="n">identifier</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.remove_callback"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.remove_callback">[docs]</a>    <span class="k">def</span> <span class="nf">remove_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">identifier</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes the callback referenced by *identifier* that is attached to the</span>
<span class="sd">        given *event*.  Example:</span>

<span class="sd">            &gt;&gt;&gt; m.remove_callback(m.CALLBACK_UPDATE, &quot;myref&quot;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">[</span><span class="n">event</span><span class="p">][</span><span class="n">identifier</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span> <span class="c"># Doesn&#39;t exist anymore--nothing to do</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.remove_all_callbacks"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.remove_all_callbacks">[docs]</a>    <span class="k">def</span> <span class="nf">remove_all_callbacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">identifier</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes all callbacks associated with *identifier*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">event</span><span class="p">,</span> <span class="n">identifiers</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">[</span><span class="n">event</span><span class="p">][</span><span class="n">identifier</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span> <span class="c"># Doesn&#39;t exist--nothing to worry about</span>
</div>
<div class="viewcode-block" id="BaseMultiplex._call_callback"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex._call_callback">[docs]</a>    <span class="k">def</span> <span class="nf">_call_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is here in the event that subclasses of `BaseMultiplex` need</span>
<span class="sd">        to call callbacks in an implementation-specific way.  It just calls</span>
<span class="sd">        *callback*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">callback</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.spawn"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.spawn">[docs]</a>    <span class="k">def</span> <span class="nf">spawn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="mi">24</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">em_dimensions</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method must be overridden by suclasses of `BaseMultiplex`.  It is</span>
<span class="sd">        expected to execute a child process in a way that allows non-blocking</span>
<span class="sd">        reads to be performed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">_</span><span class="p">(</span>
            <span class="s">&quot;spawn() *must* be overridden by subclasses.&quot;</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.isalive"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.isalive">[docs]</a>    <span class="k">def</span> <span class="nf">isalive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method must be overridden by suclasses of `BaseMultiplex`.  It is</span>
<span class="sd">        expected to return True if the child process is still alive and False</span>
<span class="sd">        otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">_</span><span class="p">(</span>
            <span class="s">&quot;isalive() *must* be overridden by subclasses.&quot;</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.term_write"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.term_write">[docs]</a>    <span class="k">def</span> <span class="nf">term_write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes :obj:`stream` to `BaseMultiplex.term` and also takes care of</span>
<span class="sd">        logging to :attr:`log_path` (if set) and/or syslog (if</span>
<span class="sd">        :attr:`syslog` is `True`).  When complete, will call any</span>
<span class="sd">        callbacks registered in :obj:`CALLBACK_UPDATE`.</span>

<span class="sd">        :stream: A string or bytes containing the incoming output stream from the underlying terminal program.</span>

<span class="sd">        .. note:: This kind of logging doesn&#39;t capture user keystrokes.  This is intentional as we don&#39;t want passwords winding up in the logs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#logging.debug(&#39;term_write() stream: %s&#39; % repr(stream))</span>
        <span class="c"># Write to the log (if configured)</span>
        <span class="n">separator</span> <span class="o">=</span> <span class="n">b</span><span class="s">&quot;</span><span class="se">\xf3\xb0\xbc\x8f</span><span class="s">&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_path</span><span class="p">:</span>
            <span class="c"># Using .encode() below ensures the result will be bytes</span>
            <span class="n">now</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)))</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&#39;UTF-8&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_path</span><span class="p">):</span>
                <span class="c"># Write the first frame as metadata</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s">&#39;version&#39;</span><span class="p">:</span> <span class="s">&#39;1.0&#39;</span><span class="p">,</span> <span class="c"># Log format version</span>
                    <span class="s">&#39;rows&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span>
                    <span class="s">&#39;cols&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">,</span>
                    <span class="s">&#39;start_date&#39;</span><span class="p">:</span> <span class="n">now</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">&#39;UTF-8&#39;</span><span class="p">)</span> <span class="c"># JSON needs strings</span>
                    <span class="c"># NOTE: end_date should be added later when the is read for</span>
                    <span class="c"># the first time by either the logviewer or the logging</span>
                    <span class="c"># plugin.</span>
                <span class="p">}</span>
                <span class="c"># The hope is that we can use the first-frame-metadata paradigm</span>
                <span class="c"># to store all sorts of useful information about a log.</span>
                <span class="c"># NOTE: Using .encode() below to ensure it is bytes in Python 3</span>
                <span class="n">metadata_frame</span> <span class="o">=</span> <span class="n">json_encode</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&#39;UTF-8&#39;</span><span class="p">)</span>
                <span class="c"># Using concatenation of bytes below to ensure compatibility</span>
                <span class="c"># with both Python 2 and Python 3.</span>
                <span class="n">metadata_frame</span> <span class="o">=</span> <span class="n">now</span> <span class="o">+</span> <span class="n">b</span><span class="s">&quot;:&quot;</span> <span class="o">+</span> <span class="n">metadata_frame</span> <span class="o">+</span> <span class="n">separator</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">metadata_frame</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span> <span class="c"># Only comes into play if the file already exists</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
            <span class="c"># NOTE: I&#39;m using an obscure unicode symbol in order to avoid</span>
            <span class="c"># conflicts.  We need to do our best to ensure that we can</span>
            <span class="c"># differentiate between terminal output and our log format...</span>
            <span class="c"># This should do the trick because it is highly unlikely that</span>
            <span class="c"># someone would be displaying this obscure unicode symbol on an</span>
            <span class="c"># actual terminal unless they were using Gate One to view a</span>
            <span class="c"># Gate One log file in vim or something =)</span>
            <span class="c"># &quot;\xf3\xb0\xbc\x8f&quot; == \U000f0f0f == U+F0F0F (Private Use Symbol)</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">now</span> <span class="o">+</span> <span class="n">b</span><span class="s">&quot;:&quot;</span> <span class="o">+</span> <span class="n">stream</span> <span class="o">+</span> <span class="n">separator</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
        <span class="c"># NOTE: Gate One&#39;s log format is special in that it can be used for both</span>
        <span class="c"># playing back recorded sessions *or* generating syslog-like output.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">syslog</span><span class="p">:</span>
            <span class="c"># Try and keep it as line-line as possible so we don&#39;t end up with</span>
            <span class="c"># a log line per character.</span>
            <span class="k">if</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span> <span class="ow">in</span> <span class="n">stream</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">stream</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">syslog_buffer</span><span class="p">:</span>
                        <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">syslog_buffer</span> <span class="o">+</span> <span class="n">line</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">syslog_buffer</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
                    <span class="c"># Sylog really doesn&#39;t like any fancy encodings</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&#39;ascii&#39;</span><span class="p">,</span> <span class="s">&#39;xmlcharrefreplace&#39;</span><span class="p">)</span>
                    <span class="n">syslog</span><span class="o">.</span><span class="n">syslog</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">term_id</span><span class="p">,</span> <span class="n">line</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">syslog_buffer</span> <span class="o">+=</span> <span class="n">stream</span>
        <span class="c"># Handle preprocess patterns (for expect())</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patterns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">preprocess</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
        <span class="c"># Handle post-process patterns (for expect())</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patterns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">postprocess</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">CALLBACK_UPDATE</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">callback</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">CALLBACK_UPDATE</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_call_callback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.preprocess"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.preprocess">[docs]</a>    <span class="k">def</span> <span class="nf">preprocess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Handles preprocess patterns registered by :meth:`expect`.  That</span>
<span class="sd">        is, those patterns which have been marked with `preprocess = True`.</span>
<span class="sd">        Patterns marked in this way get handled *before* the terminal emulator</span>
<span class="sd">        processes the :obj:`stream`.</span>

<span class="sd">        :stream: A string or bytes containing the incoming output stream from the underlying terminal program.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">preprocess_patterns</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patterns</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">preprocess</span><span class="p">)</span>
        <span class="n">finished_non_sticky</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="c"># If there aren&#39;t any preprocess patterns this won&#39;t do anything:</span>
        <span class="k">for</span> <span class="n">pattern_obj</span> <span class="ow">in</span> <span class="n">preprocess_patterns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">finished_non_sticky</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">sticky</span><span class="p">:</span>
                <span class="c"># We only want sticky patterns if we&#39;ve already matched once</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pattern_obj</span><span class="o">.</span><span class="n">pattern</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">pat</span> <span class="ow">in</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">pattern</span><span class="p">:</span>
                    <span class="n">match</span> <span class="o">=</span> <span class="n">pat</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">term_lines</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                        <span class="n">callback</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
                            <span class="n">pattern_obj</span><span class="o">.</span><span class="n">callback</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_call_callback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">sticky</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">unexpect</span><span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="n">pattern_obj</span><span class="p">))</span> <span class="c"># Remove it</span>
                        <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">match</span> <span class="o">=</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                    <span class="n">callback</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
                        <span class="n">pattern_obj</span><span class="o">.</span><span class="n">callback</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_call_callback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">sticky</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">unexpect</span><span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="n">pattern_obj</span><span class="p">))</span> <span class="c"># Remove it</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">optional</span><span class="p">:</span>
                <span class="c"># We only match the first non-optional pattern</span>
                <span class="n">finished_non_sticky</span> <span class="o">=</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.postprocess"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.postprocess">[docs]</a>    <span class="k">def</span> <span class="nf">postprocess</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Handles post-process patterns registered by :meth:`expect`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Check the terminal emulator screen for any matching patterns.</span>
        <span class="n">post_patterns</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patterns</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">preprocess</span><span class="p">)</span>
        <span class="n">finished_non_sticky</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">pattern_obj</span> <span class="ow">in</span> <span class="n">post_patterns</span><span class="p">:</span>
            <span class="c"># For post-processing matches we search the terminal emulator&#39;s</span>
            <span class="c"># screen as a single string.  This allows for full-screen screen</span>
            <span class="c"># scraping in addition to typical &#39;expect-like&#39; functionality.</span>
            <span class="c"># The big difference being that with traditional expect (and</span>
            <span class="c"># pexpect) you don&#39;t get to examine the program&#39;s output as it</span>
            <span class="c"># would be rendered in an actual terminal.</span>
            <span class="c"># By using post-processing of the text after it has been handled</span>
            <span class="c"># by a terminal emulator we don&#39;t have to worry about hidden</span>
            <span class="c"># characters and escape sequences that we may not be aware of or</span>
            <span class="c"># could make our regular expressions much more complicated than</span>
            <span class="c"># they should be.</span>
            <span class="k">if</span> <span class="n">finished_non_sticky</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">sticky</span><span class="p">:</span>
                <span class="k">continue</span> <span class="c"># We only want sticky patterns at this point</span>
            <span class="c"># For convenience, trailing whitespace is removed from the lines</span>
            <span class="c"># output from the terminal emulator.  This is so we don&#39;t have to</span>
            <span class="c"># put &#39;\w*&#39; before every &#39;$&#39; to match the end of a line.</span>
            <span class="n">term_lines</span> <span class="o">=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">dump</span><span class="p">()])</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pattern_obj</span><span class="o">.</span><span class="n">pattern</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">pat</span> <span class="ow">in</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">pattern</span><span class="p">:</span>
                    <span class="n">match</span> <span class="o">=</span> <span class="n">pat</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">term_lines</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_handle_match</span><span class="p">(</span><span class="n">pattern_obj</span><span class="p">,</span> <span class="n">match</span><span class="p">)</span>
                        <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">match</span> <span class="o">=</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">term_lines</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_handle_match</span><span class="p">(</span><span class="n">pattern_obj</span><span class="p">,</span> <span class="n">match</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">optional</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">sticky</span><span class="p">:</span>
                <span class="c"># We only match the first non-optional pattern</span>
                <span class="n">finished_non_sticky</span> <span class="o">=</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="BaseMultiplex._handle_match"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex._handle_match">[docs]</a>    <span class="k">def</span> <span class="nf">_handle_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern_obj</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Handles a matched regex detected by :meth:`postprocess`.  It calls</span>
<span class="sd">        :obj:`Pattern.callback` and takes care of removing it from</span>
<span class="sd">        :attr:`_patterns` (if it isn&#39;t sticky).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handling_match</span><span class="p">:</span>
            <span class="c"># Don&#39;t process anything if we&#39;re in the middle of handling a match.</span>
            <span class="c"># NOTE: This can happen when there&#39;s more than one thread,</span>
            <span class="c"># processes, or PeriodicCallback going on simultaneously.  It seems</span>
            <span class="c"># to work better than threading.Lock()</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_handling_match</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">callback</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">pattern_obj</span><span class="o">.</span><span class="n">callback</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call_callback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="c"># Turn on the fancy regex debugger/pretty printer</span>
            <span class="n">debug_callback</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
                <span class="n">debug_expect</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(),</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">pattern</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call_callback</span><span class="p">(</span><span class="n">debug_callback</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">sticky</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unexpect</span><span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="n">pattern_obj</span><span class="p">))</span> <span class="c"># Remove it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_handling_match</span> <span class="o">=</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.writeline"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.writeline">[docs]</a>    <span class="k">def</span> <span class="nf">writeline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Just like :meth:`write` but it writes a newline after writing *line*.</span>

<span class="sd">        If no *line* is given a newline will be written.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="s">u&#39;</span><span class="se">\r\n</span><span class="s">&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.writelines"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.writelines">[docs]</a>    <span class="k">def</span> <span class="nf">writelines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes *lines* (a list of strings) to the underlying program, appending</span>
<span class="sd">        a newline after each line.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="s">&#39;__iter__&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="s">u&#39;</span><span class="se">\r\n</span><span class="s">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_</span><span class="p">(</span>
                <span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not iterable (strings don&#39;t count :)&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">lines</span><span class="p">)))</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.dump_html"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.dump_html">[docs]</a>    <span class="k">def</span> <span class="nf">dump_html</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">client_id</span><span class="o">=</span><span class="s">&#39;0&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the difference of terminal lines (a list of lines, to be</span>
<span class="sd">        specific) and its scrollback buffer (which is also a list of lines) as a</span>
<span class="sd">        tuple::</span>

<span class="sd">            (scrollback, screen)</span>

<span class="sd">        If a line hasn&#39;t changed since the last dump said line will be replaced</span>
<span class="sd">        with an empty string in the output.</span>

<span class="sd">        If *full*, will return the entire screen (not just the diff).</span>
<span class="sd">        if *client_id* is given (string), this will be used as a unique client</span>
<span class="sd">        identifier for keeping track of screen differences (so you can have</span>
<span class="sd">        multiple clients getting their own unique diff output for the same</span>
<span class="sd">        Multiplex instance).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">client_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">prev_output</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prev_output</span><span class="p">[</span><span class="n">client_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">scrollback</span><span class="p">,</span> <span class="n">html</span> <span class="o">=</span> <span class="p">([],</span> <span class="p">[])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">dump_html</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
                        <span class="n">scrollback</span><span class="p">,</span> <span class="n">html</span> <span class="o">=</span> <span class="n">result</span>
                        <span class="c"># Make a copy so we can save it to prev_output later</span>
                        <span class="n">preserved_html</span> <span class="o">=</span> <span class="n">html</span><span class="p">[:]</span>
                <span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s">&quot;IOError attempting self.term.dump_html()&quot;</span><span class="p">))</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">html</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">full</span><span class="p">:</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">line1</span><span class="p">,</span> <span class="n">line2</span> <span class="ow">in</span> <span class="n">izip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prev_output</span><span class="p">[</span><span class="n">client_id</span><span class="p">],</span> <span class="n">html</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">line1</span> <span class="o">!=</span> <span class="n">line2</span><span class="p">:</span>
                            <span class="n">html</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">line2</span> <span class="c"># I love updates-in-place</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">html</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
                        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c"># Otherwise a full dump will take place</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">prev_output</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">client_id</span><span class="p">:</span> <span class="n">preserved_html</span><span class="p">})</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">scrollback</span><span class="p">,</span> <span class="n">html</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c"># This would be special...</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s">&quot;ValueError in dump_html(): </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">e</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">([],</span> <span class="p">[])</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">IOError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s">&quot;Unhandled exception in dump_html(): </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">e</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratelimiter_engaged</span><span class="p">:</span>
                <span class="c"># Caused by the program being out of control</span>
                <span class="k">return</span><span class="p">([],</span> <span class="p">[</span>
                    <span class="n">_</span><span class="p">(</span><span class="s">&quot;&lt;b&gt;Program output too noisy.  Sending Ctrl-c...&lt;/b&gt;&quot;</span><span class="p">)])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">traceback</span>
                <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">(</span><span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">([],</span> <span class="p">[])</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.dump"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.dump">[docs]</a>    <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dumps whatever is currently on the screen of the terminal emulator as</span>
<span class="sd">        a list of plain strings (so they&#39;ll be escaped and look nice in an</span>
<span class="sd">        interactive Python interpreter).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">dump</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.timeout_check"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.timeout_check">[docs]</a>    <span class="k">def</span> <span class="nf">timeout_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout_now</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterates over :attr:`BaseMultiplex._patterns` checking each to</span>
<span class="sd">        determine if it has timed out.  If a timeout has occurred for a</span>
<span class="sd">        `Pattern` and said Pattern has an *errorback* function that function</span>
<span class="sd">        will be called.</span>

<span class="sd">        Returns True if there are still non-sticky patterns remaining.  False</span>
<span class="sd">        otherwise.</span>

<span class="sd">        If *timeout_now* is True, will force the first errorback to be called</span>
<span class="sd">        and will empty out self._patterns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">remaining_patterns</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">pattern_obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patterns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">timeout_now</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">errorback</span><span class="p">:</span>
                    <span class="n">errorback</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">pattern_obj</span><span class="o">.</span><span class="n">errorback</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_call_callback</span><span class="p">(</span><span class="n">errorback</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">unexpect</span><span class="p">()</span>
                    <span class="k">return</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">timeout</span><span class="p">:</span>
                <span class="c"># Timeouts of 0 or None mean &quot;wait forever&quot;</span>
                <span class="n">remaining_patterns</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">continue</span>
            <span class="n">elapsed</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">created</span>
            <span class="k">if</span> <span class="n">elapsed</span> <span class="o">&gt;</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">timeout</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">sticky</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">unexpect</span><span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="n">pattern_obj</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">errorback</span><span class="p">:</span>
                    <span class="n">errorback</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">pattern_obj</span><span class="o">.</span><span class="n">errorback</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_call_callback</span><span class="p">(</span><span class="n">errorback</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">pattern_obj</span><span class="o">.</span><span class="n">sticky</span><span class="p">:</span>
                <span class="n">remaining_patterns</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="n">remaining_patterns</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.expect"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.expect">[docs]</a>    <span class="k">def</span> <span class="nf">expect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">patterns</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span>
            <span class="n">optional</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
            <span class="n">sticky</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
            <span class="n">errorback</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">timeout</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
            <span class="n">position</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">preprocess</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Watches the stream of output coming from the underlying terminal program</span>
<span class="sd">        for *patterns* and if there&#39;s a match *callback* will be called like so::</span>

<span class="sd">            callback(multiplex_instance, matched_string)</span>

<span class="sd">        .. tip:: You can provide a string instead of a *callback* function as a shortcut if you just want said string written to the child process.</span>

<span class="sd">        *patterns* can be a string, an :class:`re.RegexObject` (as created by</span>
<span class="sd">        :func:`re.compile`), or a iterator of either/or.  Returns a reference</span>
<span class="sd">        object that can be used to remove the registered pattern/callback at any</span>
<span class="sd">        time using the :meth:`unexpect` method (see below).</span>

<span class="sd">        .. note::  This function is non-blocking!</span>

<span class="sd">        .. warning::  The *timeout* value gets compared against the time :meth:`expect` was called to create it.  So don&#39;t wait too long if you&#39;re planning on using :meth:`await`!</span>

<span class="sd">        Here&#39;s a simple example that changes a user&#39;s password::</span>

<span class="sd">            &gt;&gt;&gt; def write_password(m_instance, matched):</span>
<span class="sd">            ...     print(&quot;Sending Password... %s patterns remaining.&quot; % len(m_instance._patterns))</span>
<span class="sd">            ...     m_instance.writeline(&#39;somepassword&#39;)</span>
<span class="sd">            &gt;&gt;&gt; m = Multiplex(&#39;passwd someuser&#39;) # Assumes running as root :)</span>
<span class="sd">            &gt;&gt;&gt; m.expect(&#39;(?i)password:&#39;, write_password) # Step 1</span>
<span class="sd">            &gt;&gt;&gt; m.expect(&#39;(?i)password:&#39;, write_password) # Step 2</span>
<span class="sd">            &gt;&gt;&gt; print(len(m._patterns)) # To show that there&#39;s two in the queue</span>
<span class="sd">                2</span>
<span class="sd">            &gt;&gt;&gt; m.spawn() # Execute the command</span>
<span class="sd">            &gt;&gt;&gt; m.await(10) # This will block for up to 10 seconds waiting for self._patterns to be empty (not counting optional patterns)</span>
<span class="sd">            Sending Password... 1 patterns remaining.</span>
<span class="sd">            Sending Password... 0 patterns remaining.</span>
<span class="sd">            &gt;&gt;&gt; m.isalive()</span>
<span class="sd">            False</span>
<span class="sd">            &gt;&gt;&gt; # All done!</span>

<span class="sd">        .. tip:: The :meth:`await` method will automatically call :meth:`spawn` if not :meth:`isalive`.</span>

<span class="sd">        This would result in the password of &#39;someuser&#39; being changed to &#39;somepassword&#39;.  How is the order determined?  Every time :meth:`expect` is called it creates a new :class:`Pattern` using the given parameters and appends it to `self._patterns` (which is a list).  As each :class:`Pattern` is matched its *callback* gets called and the :class:`Pattern` is removed from `self._patterns` (unless *sticky* is `True`).  So even though the patterns and callbacks listed above were identical they will get executed and removed in the order they were created as each respective :class:`Pattern` is matched.</span>

<span class="sd">        .. note:: Only the first pattern, or patterns marked as *sticky* are checked against the incoming stream.  If the first non-sticky pattern is marked *optional* then the proceeding pattern will be checked (and so on).  All other patterns will sit in `self._patterns` until their predecessors are matched/removed.</span>

<span class="sd">        Patterns can be removed from `self._patterns` as needed by calling `unexpect(&lt;reference&gt;)`.  Here&#39;s an example::</span>

<span class="sd">            &gt;&gt;&gt; def handle_accepting_ssh_key(m_instance, matched):</span>
<span class="sd">            ...     m_instance.writeline(u&#39;yes&#39;)</span>
<span class="sd">            &gt;&gt;&gt; m = Multiplex(&#39;ssh someuser@somehost&#39;)</span>
<span class="sd">            &gt;&gt;&gt; ref1 = m.expect(&#39;(?i)Are you sure.*\(yes/no\)\?&#39;, handle_accepting_ssh_key, optional=True)</span>
<span class="sd">            &gt;&gt;&gt; def send_password(m_instance, matched):</span>
<span class="sd">            ...    m_instance.unexpect(ref1)</span>
<span class="sd">            ...    self.writeline(&#39;somepassword&#39;)</span>
<span class="sd">            &gt;&gt;&gt; ref2 = m.expect(&#39;(?i)password:&#39;, send_password)</span>
<span class="sd">            &gt;&gt;&gt; # spawn() and/or await() and do stuff...</span>

<span class="sd">        The example above would send &#39;yes&#39; if asked by the SSH program to accept</span>
<span class="sd">        the host&#39;s public key (which would result in it being automatically</span>
<span class="sd">        removed from `self._patterns`).  However, if this condition isn&#39;t met</span>
<span class="sd">        before send_password() is called, send_password() will use the reference</span>
<span class="sd">        object to remove it directly.  This ensures that the pattern won&#39;t be</span>
<span class="sd">        accidentally matched later on in the program&#39;s execution.</span>

<span class="sd">        .. note:: Even if we didn&#39;t match the &quot;Are you sure...&quot; pattern it would still get auto-removed after its timeout was reached.</span>

<span class="sd">        **About pattern ordering:** The position at which the given pattern will</span>
<span class="sd">        be inserted in `self._patterns` can be specified via the</span>
<span class="sd">        *position* argument.  The default is to simply append which should be</span>
<span class="sd">        appropriate in most cases.</span>

<span class="sd">        **About Timeouts:** The *timeout* value passed to expect() will be used</span>
<span class="sd">        to determine how long to wait before the pattern is removed from</span>
<span class="sd">        self._patterns.  When this occurs, *errorback* will be called with</span>
<span class="sd">        current Multiplex instance as the only argument.  If *errorback* is None</span>
<span class="sd">        (the default) the pattern will simply be discarded with no action taken.</span>

<span class="sd">        .. note:: If *sticky* is True the *timeout* value will be ignored.</span>

<span class="sd">        **Notes about the length of what will be matched:**  The entire terminal</span>
<span class="sd">        &#39;screen&#39; will be searched every time new output is read from the</span>
<span class="sd">        incoming stream.  This means that the number of rows and columns of the</span>
<span class="sd">        terminal determines the size of the search.  So if your pattern needs to</span>
<span class="sd">        look for something inside of 50 lines of text you need to make sure that</span>
<span class="sd">        when you call `spawn` you specify at least `rows = 50`.  Example::</span>

<span class="sd">            &gt;&gt;&gt; def handle_long_search(m_instance, matched)</span>
<span class="sd">            ...     do_stuff(matched)</span>
<span class="sd">            &gt;&gt;&gt; m = Multiplex(&#39;someCommandWithLotsOfOutput.sh&#39;)</span>
<span class="sd">            &gt;&gt;&gt; # &#39;begin&#39;, at least one non-newline char, 50 newlines, at least one char, then &#39;end&#39;:</span>
<span class="sd">            &gt;&gt;&gt; my_regex = re.compile(&#39;begin.+[\\n]{50}.+end&#39;, re.MULTILINE)</span>
<span class="sd">            &gt;&gt;&gt; ref = m.expect(my_regex, handle_accepting_ssh_key)</span>
<span class="sd">            &gt;&gt;&gt; m.spawn(rows=51, cols=150)</span>
<span class="sd">            &gt;&gt;&gt; # Call m.read(), m.spawn() or just let an event loop (e.g. Tornado&#39;s IOLoop) take care of things...</span>

<span class="sd">        **About non-printable characters:** If the *postprocess* argument is</span>
<span class="sd">        True (the default), patterns will be checked against the current screen as</span>
<span class="sd">        output by the terminal emulator.  This means that things like control</span>
<span class="sd">        codes and escape sequences will be handled and discarded by the terminal</span>
<span class="sd">        emulator and as such won&#39;t be available for patterns to be checked</span>
<span class="sd">        against.  To get around this limitation you can set *preprocess* to True</span>
<span class="sd">        and the pattern will be checked against the incoming stream before it is</span>
<span class="sd">        processed by the terminal emulator.  Example::</span>

<span class="sd">            &gt;&gt;&gt; def handle_xterm_title(m_instance, matched)</span>
<span class="sd">            ...     print(&quot;Caught title: %s&quot; % matched)</span>
<span class="sd">            &gt;&gt;&gt; m = Multiplex(&#39;echo -e &quot;\\033]0;Some Title\\007&quot;&#39;)</span>
<span class="sd">            &gt;&gt;&gt; title_seq_regex = re.compile(r&#39;\\x1b\\][0-2]\;(.*?)(\\x07|\\x1b\\\\)&#39;)</span>
<span class="sd">            &gt;&gt;&gt; m.expect(title_seq_regex, handle_xterm_title, preprocess=True) # &lt;-- &#39;preprocess=True&#39;</span>
<span class="sd">            &gt;&gt;&gt; m.await()</span>
<span class="sd">            Caught title: Some Title</span>
<span class="sd">            &gt;&gt;&gt;</span>

<span class="sd">        **Notes about debugging:** Instead of using `await` to wait for all of your patterns to be matched at once you can make individual calls to `read` to determine if your patterns are being matched in the way that you want.  For example::</span>

<span class="sd">            &gt;&gt;&gt; def do_stuff(m_instance, matched):</span>
<span class="sd">            ...     print(&quot;Debug: do_stuff() got %s&quot; % repr(matched))</span>
<span class="sd">            ...     # Do stuff here</span>
<span class="sd">            &gt;&gt;&gt; m = Multiplex(&#39;someLongComplicatedOutput.sh&#39;)</span>
<span class="sd">            &gt;&gt;&gt; m.expect(&#39;some pattern&#39;, do_stuff)</span>
<span class="sd">            &gt;&gt;&gt; m.expect(&#39;some other pattern&#39;, do_stuff)</span>
<span class="sd">            &gt;&gt;&gt; m.spawn()</span>
<span class="sd">            &gt;&gt;&gt; # Instead of calling await() just call one read() at a time...</span>
<span class="sd">            &gt;&gt;&gt; print(repr(m.read()))</span>
<span class="sd">            &#39;&#39;</span>
<span class="sd">            &gt;&gt;&gt; print(repr(m.read())) # Oops, called read() too soon.  Try again:</span>
<span class="sd">            &#39;some other pattern&#39;</span>
<span class="sd">            &gt;&gt;&gt; # Doh!  Looks like &#39;some other pattern&#39; comes first.  Let&#39;s start over...</span>
<span class="sd">            &gt;&gt;&gt; m.unexpect() # Called with no arguments, it empties m._patterns</span>
<span class="sd">            &gt;&gt;&gt; m.terminate() # Tip: This will call unexpect() too so the line above really isn&#39;t necessary</span>
<span class="sd">            &gt;&gt;&gt; m.expect(&#39;some other pattern&#39;, do_stuff) # This time this one will be first</span>
<span class="sd">            &gt;&gt;&gt; m.expect(&#39;some pattern&#39;, do_stuff)</span>
<span class="sd">            &gt;&gt;&gt; m.spawn()</span>
<span class="sd">            &gt;&gt;&gt; print(repr(m.read())) # This time I waited a moment :)</span>
<span class="sd">            &#39;Debug: do_stuff() got &quot;some other pattern&quot;&#39;</span>
<span class="sd">            &#39;some other pattern&#39;</span>
<span class="sd">            &gt;&gt;&gt; # Huzzah!  Now let&#39;s see if &#39;some pattern&#39; matches...</span>
<span class="sd">            &gt;&gt;&gt; print(repr(m.read()))</span>
<span class="sd">            &#39;Debug: do_stuff() got &quot;some pattern&quot;&#39;</span>
<span class="sd">            &#39;some pattern&#39;</span>
<span class="sd">            &gt;&gt;&gt; # As you can see, calling read() at-will in an interactive interpreter can be very handy.</span>

<span class="sd">        **About asynchronous use:**  This mechanism is non-blocking (with the exception of `await`) and is meant to be used asynchronously.  This means that if the running program has no output, `read` won&#39;t result in any patterns being matched.  So you must be careful about timing *or* you need to ensure that `read` gets called either automatically when there&#39;s data to be read (IOLoop, EPoll, select, etc) or at regular intervals via a loop.  Also, if you&#39;re not calling `read` at an interval (i.e. you&#39;re using a mechanism to detect when there&#39;s output to be read before calling it e.g. IOLoop) you need to ensure that `timeout_check` is called regularly anyway or timeouts won&#39;t get detected if there&#39;s no output from the underlying program.  See the `MultiplexPOSIXIOLoop.read` override for an example of what this means and how to do it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Create the Pattern object before we do anything else</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">patterns</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">unicode</span><span class="p">)):</span>
            <span class="c"># Convert to a compiled regex (assume MULTILINE for the sanity of</span>
            <span class="c"># the ignorant)</span>
            <span class="n">patterns</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">patterns</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">patterns</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="c"># Ensure that all patterns are RegexObjects</span>
            <span class="n">pattern_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
                    <span class="n">pattern_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pattern_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
            <span class="n">patterns</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pattern_list</span><span class="p">)</span> <span class="c"># No reason to keep it as a list</span>
        <span class="c"># Convert timeout to a timedelta if necessary</span>
        <span class="k">if</span> <span class="n">timeout</span><span class="p">:</span> <span class="c"># 0 or None mean &quot;wait forever&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                <span class="n">timeout</span> <span class="o">=</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">timeout</span><span class="p">))</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="n">timedelta</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_</span><span class="p">(</span>
                    <span class="s">&quot;The timeout value must be a string, integer, float, or a &quot;</span>
                    <span class="s">&quot;timedelta object&quot;</span><span class="p">))</span>
        <span class="n">pattern_obj</span> <span class="o">=</span> <span class="n">Pattern</span><span class="p">(</span><span class="n">patterns</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span>
            <span class="n">optional</span><span class="o">=</span><span class="n">optional</span><span class="p">,</span>
            <span class="n">sticky</span><span class="o">=</span><span class="n">sticky</span><span class="p">,</span>
            <span class="n">errorback</span><span class="o">=</span><span class="n">errorback</span><span class="p">,</span>
            <span class="n">preprocess</span><span class="o">=</span><span class="n">preprocess</span><span class="p">,</span>
            <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">position</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_patterns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pattern_obj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_patterns</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">pattern_obj</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="n">pattern_obj</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.unexpect"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.unexpect">[docs]</a>    <span class="k">def</span> <span class="nf">unexpect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes *ref* from self._patterns so it will no longer be checked</span>
<span class="sd">        against the incoming stream.  If *ref* is None (the default),</span>
<span class="sd">        `self._patterns` will be emptied.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ref</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_patterns</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># Reset</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_patterns</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hash</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">==</span> <span class="n">ref</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_patterns</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.await"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.await">[docs]</a>    <span class="k">def</span> <span class="nf">await</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Blocks until all non-optional patterns inside self._patterns have been</span>
<span class="sd">        removed *or* if the given *timeout* is reached.  *timeout* may be an</span>
<span class="sd">        integer (in seconds) or a `datetime.timedelta` object.</span>

<span class="sd">        Returns True if all non-optional, non-sticky patterns were handled</span>
<span class="sd">        successfully.</span>

<span class="sd">        .. warning:: The timeouts attached to Patterns are set when they are created.  Not when when you call :meth:`await`!</span>

<span class="sd">        As a convenience, if :meth:`isalive` resolves to False,</span>
<span class="sd">        :meth:`spawn` will be called automatically with *\*\*kwargs*</span>

<span class="sd">        await</span>
<span class="sd">            To wait with expectation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isalive</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
        <span class="c"># Convert timeout to a timedelta if necessary</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">timeout</span> <span class="o">=</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">timeout</span><span class="p">))</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="n">timedelta</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_</span><span class="p">(</span>
                <span class="s">&quot;The timeout value must be a string, integer, float, or a &quot;</span>
                <span class="s">&quot;timedelta object&quot;</span><span class="p">))</span>
        <span class="n">remaining_patterns</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="c"># This starts up the scheduler that constantly checks patterns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># Remember:  read() is non-blocking</span>
        <span class="k">while</span> <span class="n">remaining_patterns</span><span class="p">:</span>
            <span class="c"># First we need to discount optional patterns</span>
            <span class="n">remaining_patterns</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patterns</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patterns</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">pattern</span><span class="o">.</span><span class="n">optional</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pattern</span><span class="o">.</span><span class="n">sticky</span><span class="p">:</span>
                    <span class="n">remaining_patterns</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">break</span>
            <span class="c"># Now check if we&#39;ve timed out</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">timeout</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">Timeout</span><span class="p">(</span><span class="s">&quot;Lingered longer than </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">timeout</span><span class="o">.</span><span class="n">seconds</span><span class="p">)</span>
            <span class="c"># Lastly we perform a read() to ensure the output is processed</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># Remember:  read() is non-blocking</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span> <span class="c"># So we don&#39;t eat up all the CPU</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.terminate"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.terminate">[docs]</a>    <span class="k">def</span> <span class="nf">terminate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method must be overridden by suclasses of `BaseMultiplex`.  It is</span>
<span class="sd">        expected to terminate/kill the child process.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">_</span><span class="p">(</span>
            <span class="s">&quot;terminate() *must* be overridden by subclasses.&quot;</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="BaseMultiplex._read"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex._read">[docs]</a>    <span class="k">def</span> <span class="nf">_read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">bytes</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method must be overridden by subclasses of `BaseMultiplex`.  It is</span>
<span class="sd">        expected that this method read the output from the running terminal</span>
<span class="sd">        program in a non-blocking way, pass the result into `term_write`, and</span>
<span class="sd">        then return the result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">_</span><span class="p">(</span>
            <span class="s">&quot;_read() *must* be overridden by subclasses.&quot;</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="BaseMultiplex.read"><a class="viewcode-back" href="../Developer/termio.html#termio.BaseMultiplex.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">bytes</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calls `_read` and checks if any timeouts have been reached in</span>
<span class="sd">        `self._patterns`.  Returns the result of `_read`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)</span>
        <span class="c"># Perform checks for timeouts in self._patterns (used by self.expect())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeout_check</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>
</div>
    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">_</span><span class="p">(</span>
            <span class="s">&quot;write() *must* be overridden by subclasses.&quot;</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="MultiplexPOSIXIOLoop"><a class="viewcode-back" href="../Developer/termio.html#termio.MultiplexPOSIXIOLoop">[docs]</a><span class="k">class</span> <span class="nc">MultiplexPOSIXIOLoop</span><span class="p">(</span><span class="n">BaseMultiplex</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The MultiplexPOSIXIOLoop class takes care of executing a child process on</span>
<span class="sd">    POSIX (aka Unix) systems and keeping track of its state via a terminal</span>
<span class="sd">    emulator (`terminal.Terminal` by default).  If there&#39;s a started instance</span>
<span class="sd">    of :class:`tornado.ioloop.IOLoop`, handlers will be added to it that</span>
<span class="sd">    automatically keep the terminal emulator synchronized with the output of the</span>
<span class="sd">    child process.</span>

<span class="sd">    If there&#39;s no IOLoop (or it just isn&#39;t started), terminal applications can</span>
<span class="sd">    be interacted with by calling `MultiplexPOSIXIOLoop.read` (to write any</span>
<span class="sd">    pending output to the terminal emulator) and `MultiplexPOSIXIOLoop.write`</span>
<span class="sd">    (which writes directly to stdin of the child).</span>

<span class="sd">    .. note:: `MultiplexPOSIXIOLoop.read` is non-blocking.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MultiplexPOSIXIOLoop</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">tornado</span> <span class="kn">import</span> <span class="n">ioloop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terminating</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sent_sigint</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span> <span class="o">=</span> <span class="n">ioloop</span><span class="o">.</span><span class="n">IOLoop</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span> <span class="c"># Monitors child for activity</span>
        <span class="c">#self.io_loop.set_blocking_signal_threshold(2, self._blocked_io_handler)</span>
        <span class="c">#signal.signal(signal.SIGALRM, self._blocked_io_handler)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reenable_timeout</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="mi">100</span> <span class="c"># A 0.1 second interval should be fast enough</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span> <span class="o">=</span> <span class="n">ioloop</span><span class="o">.</span><span class="n">PeriodicCallback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_timeout_checker</span><span class="p">,</span><span class="n">interval</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exitstatus</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_checking_patterns</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_timeout</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">capture_limit</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c"># Huge reads by default</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">restore_rate</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes sure that the underlying terminal program is terminated so we</span>
<span class="sd">        don&#39;t leave things hanging around.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;MultiplexPOSIXIOLoop.__del__()&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>

<div class="viewcode-block" id="MultiplexPOSIXIOLoop._call_callback"><a class="viewcode-back" href="../Developer/termio.html#termio.MultiplexPOSIXIOLoop._call_callback">[docs]</a>    <span class="k">def</span> <span class="nf">_call_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If the IOLoop is started, adds the callback via</span>
<span class="sd">        :meth:`IOLoop.add_callback` to ensure it gets called at the next IOLoop</span>
<span class="sd">        iteration (which is thread safe).  If the IOLoop isn&#39;t started</span>
<span class="sd">        *callback* will get called immediately and directly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">running</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">add_callback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">callback</span><span class="p">()</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">callback</span>
</div>
<div class="viewcode-block" id="MultiplexPOSIXIOLoop._reenable_output"><a class="viewcode-back" href="../Developer/termio.html#termio.MultiplexPOSIXIOLoop._reenable_output">[docs]</a>    <span class="k">def</span> <span class="nf">_reenable_output</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Restarts capturing output from the underlying terminal program by</span>
<span class="sd">        disengaging the rate limiter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Disabling rate limiter&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratelimiter_engaged</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">add_handler</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ioloop_read_handler</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">READ</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
            <span class="c"># Already been re-added...  Probably by write().  Ignore.</span>
            <span class="k">pass</span>
</div>
    <span class="k">def</span> <span class="nf">__reset_sent_sigint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sent_sigint</span> <span class="o">=</span> <span class="bp">False</span>

<div class="viewcode-block" id="MultiplexPOSIXIOLoop._blocked_io_handler"><a class="viewcode-back" href="../Developer/termio.html#termio.MultiplexPOSIXIOLoop._blocked_io_handler">[docs]</a>    <span class="k">def</span> <span class="nf">_blocked_io_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signum</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">wait</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Handles the situation where a terminal is blocking IO (usually because</span>
<span class="sd">        of too much output).  This method would typically get called inside of</span>
<span class="sd">        `MultiplexPOSIXIOLoop._read` when the output of an fd is too noisy.</span>

<span class="sd">        If *wait* is given, will wait that many milliseconds long before</span>
<span class="sd">        disengaging the rate limiter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isalive</span><span class="p">():</span>
            <span class="c"># This can happen if terminate() gets called too fast from another</span>
            <span class="c"># thread...  Strange stuff, mixing threading, signals, and</span>
            <span class="c"># multiprocessing!</span>
            <span class="k">return</span> <span class="c"># Nothing to do</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">_</span><span class="p">(</span>
            <span class="s">&quot;Noisy process (</span><span class="si">%s</span><span class="s">) kicked off rate limiter.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">pid</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">wait</span><span class="p">:</span>
            <span class="n">wait</span> <span class="o">=</span> <span class="mi">5000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratelimiter_engaged</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="c"># CALLBACK_UPDATE is called here so the client can be made aware of the</span>
        <span class="c"># fact that the rate limiter was engaged.</span>
        <span class="k">for</span> <span class="n">callback</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">CALLBACK_UPDATE</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call_callback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">remove_handler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reenable_timeout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">add_timeout</span><span class="p">(</span>
            <span class="n">timedelta</span><span class="p">(</span><span class="n">milliseconds</span><span class="o">=</span><span class="n">wait</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reenable_output</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="MultiplexPOSIXIOLoop.spawn"><a class="viewcode-back" href="../Developer/termio.html#termio.MultiplexPOSIXIOLoop.spawn">[docs]</a>    <span class="k">def</span> <span class="nf">spawn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">rows</span><span class="o">=</span><span class="mi">24</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">em_dimensions</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">exitfunc</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new virtual terminal (tty) and executes self.cmd within it.</span>
<span class="sd">        Also attaches :meth:`self._ioloop_read_handler` to the IOLoop so that</span>
<span class="sd">        the terminal emulator will automatically stay in sync with the output of</span>
<span class="sd">        the child process.</span>

<span class="sd">        :cols: The number of columns to emulate on the virtual terminal (width)</span>
<span class="sd">        :rows: The number of rows to emulate (height).</span>
<span class="sd">        :env: Optional - A dictionary of environment variables to set when executing self.cmd.</span>
<span class="sd">        :em_dimensions: Optional - The dimensions of a single character within the terminal (only used when calculating the number of rows/cols images take up).</span>
<span class="sd">        :exitfunc: Optional - A function that will be called with the current Multiplex instance and its exit status when the child process terminates (*exitfunc(m_instance, statuscode)*).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">started</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
        <span class="c">#signal.signal(signal.SIGCHLD, signal.SIG_IGN) # No zombies allowed</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s">&quot;spawn(rows=</span><span class="si">%s</span><span class="s">, cols=</span><span class="si">%s</span><span class="s">, env=</span><span class="si">%s</span><span class="s">, em_dimensions=</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">env</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">em_dimensions</span><span class="p">)))</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="n">rows</span><span class="p">)</span> <span class="c"># Max 200 to limit memory utilization</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="n">cols</span><span class="p">)</span> <span class="c"># Max 500 for the same reason</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">=</span> <span class="n">rows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="n">cols</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">em_dimensions</span> <span class="o">=</span> <span class="n">em_dimensions</span>
        <span class="kn">import</span> <span class="nn">pty</span>
        <span class="n">pid</span><span class="p">,</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">pty</span><span class="o">.</span><span class="n">fork</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c"># We&#39;re inside the child process</span>
    <span class="c"># Close all file descriptors other than stdin, stdout, and stderr (0, 1, 2)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c"># This ensures that the child doesn&#39;t get the parent&#39;s FDs</span>
                <span class="n">os</span><span class="o">.</span><span class="n">closerange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">env</span><span class="p">:</span>
                <span class="n">env</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">env</span><span class="p">[</span><span class="s">&quot;COLUMNS&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
            <span class="n">env</span><span class="p">[</span><span class="s">&quot;LINES&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
            <span class="n">env</span><span class="p">[</span><span class="s">&quot;TERM&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;xterm-256color&quot;</span> <span class="c"># TODO: Needs to be configurable</span>
            <span class="n">env</span><span class="p">[</span><span class="s">&quot;PATH&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&#39;PATH&#39;</span><span class="p">]</span>
            <span class="n">env</span><span class="p">[</span><span class="s">&quot;LANG&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;LANG&#39;</span><span class="p">,</span> <span class="s">&#39;en_US.UTF-8&#39;</span><span class="p">)</span>
            <span class="n">env</span><span class="p">[</span><span class="s">&quot;PYTHONIOENCODING&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;utf_8&quot;</span>
            <span class="c"># Setup stdout to be more Gate One friendly</span>
            <span class="kn">import</span> <span class="nn">termios</span>
            <span class="c"># Fix missing termios.IUTF8</span>
            <span class="k">if</span> <span class="s">&#39;IUTF8&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">termios</span><span class="o">.</span><span class="n">__dict__</span><span class="p">:</span>
                <span class="n">termios</span><span class="o">.</span><span class="n">IUTF8</span> <span class="o">=</span> <span class="mi">16384</span> <span class="c"># Hopefully not platform independent</span>
            <span class="n">stdin</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">stdout</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">stderr</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="n">termios</span><span class="o">.</span><span class="n">tcgetattr</span><span class="p">(</span><span class="n">stdout</span><span class="p">)</span>
            <span class="n">iflag</span><span class="p">,</span> <span class="n">oflag</span><span class="p">,</span> <span class="n">cflag</span><span class="p">,</span> <span class="n">lflag</span><span class="p">,</span> <span class="n">ispeed</span><span class="p">,</span> <span class="n">ospeed</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">attrs</span>
            <span class="c"># Enable flow control and UTF-8 input (probably not needed)</span>
            <span class="n">iflag</span> <span class="o">|=</span> <span class="p">(</span><span class="n">termios</span><span class="o">.</span><span class="n">IXON</span> <span class="o">|</span> <span class="n">termios</span><span class="o">.</span><span class="n">IXOFF</span> <span class="o">|</span> <span class="n">termios</span><span class="o">.</span><span class="n">IUTF8</span><span class="p">)</span>
            <span class="c"># OPOST: Enable post-processing of chars (not sure if this matters)</span>
            <span class="c"># INLCR: We&#39;re disabling this so we don&#39;t get \r\r\n anywhere</span>
            <span class="n">oflag</span> <span class="o">|=</span> <span class="p">(</span><span class="n">termios</span><span class="o">.</span><span class="n">OPOST</span> <span class="o">|</span> <span class="n">termios</span><span class="o">.</span><span class="n">ONLCR</span> <span class="o">|</span> <span class="n">termios</span><span class="o">.</span><span class="n">INLCR</span><span class="p">)</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">iflag</span><span class="p">,</span> <span class="n">oflag</span><span class="p">,</span> <span class="n">cflag</span><span class="p">,</span> <span class="n">lflag</span><span class="p">,</span> <span class="n">ispeed</span><span class="p">,</span> <span class="n">ospeed</span><span class="p">,</span> <span class="n">cc</span><span class="p">]</span>
            <span class="n">termios</span><span class="o">.</span><span class="n">tcsetattr</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="n">termios</span><span class="o">.</span><span class="n">TCSANOW</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>
            <span class="c"># Now do the same for stdin</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="n">termios</span><span class="o">.</span><span class="n">tcgetattr</span><span class="p">(</span><span class="n">stdin</span><span class="p">)</span>
            <span class="n">iflag</span><span class="p">,</span> <span class="n">oflag</span><span class="p">,</span> <span class="n">cflag</span><span class="p">,</span> <span class="n">lflag</span><span class="p">,</span> <span class="n">ispeed</span><span class="p">,</span> <span class="n">ospeed</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">attrs</span>
            <span class="n">iflag</span> <span class="o">|=</span> <span class="p">(</span><span class="n">termios</span><span class="o">.</span><span class="n">IXON</span> <span class="o">|</span> <span class="n">termios</span><span class="o">.</span><span class="n">IXOFF</span> <span class="o">|</span> <span class="n">termios</span><span class="o">.</span><span class="n">IUTF8</span><span class="p">)</span>
            <span class="n">oflag</span> <span class="o">|=</span> <span class="p">(</span><span class="n">termios</span><span class="o">.</span><span class="n">OPOST</span> <span class="o">|</span> <span class="n">termios</span><span class="o">.</span><span class="n">ONLCR</span> <span class="o">|</span> <span class="n">termios</span><span class="o">.</span><span class="n">INLCR</span><span class="p">)</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">iflag</span><span class="p">,</span> <span class="n">oflag</span><span class="p">,</span> <span class="n">cflag</span><span class="p">,</span> <span class="n">lflag</span><span class="p">,</span> <span class="n">ispeed</span><span class="p">,</span> <span class="n">ospeed</span><span class="p">,</span> <span class="n">cc</span><span class="p">]</span>
            <span class="n">termios</span><span class="o">.</span><span class="n">tcsetattr</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span> <span class="n">termios</span><span class="o">.</span><span class="n">TCSANOW</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>
            <span class="c"># The sleep statement below ensures we capture all output from the</span>
            <span class="c"># fd before it is closed...  It turns out that IOLoop&#39;s response to</span>
            <span class="c"># changes in the fd is so fast that it can result in the fd being</span>
            <span class="c"># closed the very moment the Python interpreter is reading from it.</span>
            <span class="n">cmd</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;/bin/sh&#39;</span><span class="p">,</span> <span class="s">&#39;-c&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cmd</span> <span class="o">+</span> <span class="s">&#39;; sleep .1&#39;</span><span class="p">]</span>
            <span class="n">os</span><span class="o">.</span><span class="n">dup2</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c"># Copy stderr to stdout (equivalent to 2&gt;&amp;1)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">execvpe</span><span class="p">(</span><span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c"># We&#39;re inside this Python script</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;spawn() pid: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">pid</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_alive</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">env</span> <span class="o">=</span> <span class="n">env</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exitfunc</span> <span class="o">=</span> <span class="n">exitfunc</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pid</span> <span class="o">=</span> <span class="n">pid</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terminal_emulator</span><span class="p">(</span>
                    <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span>
                    <span class="n">cols</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span>
                    <span class="n">em_dimensions</span><span class="o">=</span><span class="n">em_dimensions</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c"># Terminal emulator doesn&#39;t support em_dimensions.  That&#39;s OK</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">terminal_emulator</span><span class="p">(</span>
                    <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span>
                    <span class="n">cols</span><span class="o">=</span><span class="n">cols</span>
                <span class="p">)</span>
            <span class="c"># Tell our IOLoop instance to start watching the child</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">add_handler</span><span class="p">(</span>
                <span class="n">fd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ioloop_read_handler</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">READ</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prev_output</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c"># Set non-blocking so we don&#39;t wait forever for a read()</span>
            <span class="kn">import</span> <span class="nn">fcntl</span>
            <span class="n">fl</span> <span class="o">=</span> <span class="n">fcntl</span><span class="o">.</span><span class="n">fcntl</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="p">,</span> <span class="n">fcntl</span><span class="o">.</span><span class="n">F_GETFL</span><span class="p">)</span>
            <span class="n">fcntl</span><span class="o">.</span><span class="n">fcntl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fd</span><span class="p">,</span> <span class="n">fcntl</span><span class="o">.</span><span class="n">F_SETFL</span><span class="p">,</span> <span class="n">fl</span> <span class="o">|</span> <span class="n">os</span><span class="o">.</span><span class="n">O_NONBLOCK</span><span class="p">)</span>
            <span class="c"># Set the size of the terminal</span>
            <span class="n">resize</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resize</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">ctrl_l</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">add_timeout</span><span class="p">(</span><span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">resize</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">fd</span>
</div>
<div class="viewcode-block" id="MultiplexPOSIXIOLoop.isalive"><a class="viewcode-back" href="../Developer/termio.html#termio.MultiplexPOSIXIOLoop.isalive">[docs]</a>    <span class="k">def</span> <span class="nf">isalive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks the underlying process to see if it is alive and sets self._alive</span>
<span class="sd">        appropriately.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alive</span><span class="p">:</span> <span class="c"># Re-check it</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">kill</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c"># kill -0 tells us it&#39;s still alive</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alive</span>
            <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                <span class="c"># Process is dead</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_alive</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">_</span><span class="p">(</span>
                    <span class="s">&quot;Child exited with status: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">exitstatus</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="MultiplexPOSIXIOLoop.resize"><a class="viewcode-back" href="../Developer/termio.html#termio.MultiplexPOSIXIOLoop.resize">[docs]</a>    <span class="k">def</span> <span class="nf">resize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">em_dimensions</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ctrl_l</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resizes the child process&#39;s terminal window to *rows* and *cols* by</span>
<span class="sd">        first sending it a TIOCSWINSZ event and then sending ctrl-l.</span>

<span class="sd">        If *em_dimensions* are provided they will be updated along with the</span>
<span class="sd">        rows and cols.</span>

<span class="sd">        The sending of ctrl-l can be disabled by setting *ctrl_l* to False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Resizing term </span><span class="si">%s</span><span class="s"> to rows: </span><span class="si">%s</span><span class="s">, cols: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">term_id</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">rows</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">rows</span> <span class="o">=</span> <span class="mi">24</span>
        <span class="k">if</span> <span class="n">cols</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="mi">80</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">=</span> <span class="n">rows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="n">cols</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">em_dimensions</span><span class="p">)</span>
        <span class="c"># Sometimes the resize doesn&#39;t actually apply (for whatever reason)</span>
        <span class="c"># so to get around this we have to send a different value than the</span>
        <span class="c"># actual value we want then send our actual value.  It&#39;s a bug outside</span>
        <span class="c"># of Gate One that I have no idea how to isolate but this has proven to</span>
        <span class="c"># be an effective workaround.</span>
        <span class="kn">import</span> <span class="nn">fcntl</span><span class="o">,</span> <span class="nn">termios</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s">&quot;HHHH&quot;</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">fcntl</span><span class="o">.</span><span class="n">ioctl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fd</span><span class="p">,</span> <span class="n">termios</span><span class="o">.</span><span class="n">TIOCSWINSZ</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
            <span class="c"># Process already ended--no big deal</span>
            <span class="k">return</span>
        <span class="n">os</span><span class="o">.</span><span class="n">kill</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pid</span><span class="p">,</span> <span class="n">signal</span><span class="o">.</span><span class="n">SIGWINCH</span><span class="p">)</span> <span class="c"># Send the resize signal</span>
        <span class="k">if</span> <span class="n">ctrl_l</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">u&#39;</span><span class="se">\x0c</span><span class="s">&#39;</span><span class="p">)</span> <span class="c"># ctrl-l</span>
</div>
<div class="viewcode-block" id="MultiplexPOSIXIOLoop.terminate"><a class="viewcode-back" href="../Developer/termio.html#termio.MultiplexPOSIXIOLoop.terminate">[docs]</a>    <span class="k">def</span> <span class="nf">terminate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Kill the child process associated with `self.fd`.</span>

<span class="sd">        .. note:: If dtach is being used this only kills the dtach process.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">terminating</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">terminating</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="c"># Something else already called it</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;terminate() self.pid: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">pid</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reenable_timeout</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">remove_timeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reenable_timeout</span><span class="p">)</span>
        <span class="c"># Unset our blocked IO handler so there&#39;s no references to self hanging</span>
        <span class="c"># around preventing us from freeing up memory</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">set_blocking_signal_threshold</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span> <span class="c"># Can happen if this instance winds up in a thread</span>
        <span class="k">for</span> <span class="n">callback</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">CALLBACK_EXIT</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call_callback</span><span class="p">(</span><span class="n">callback</span><span class="p">)</span>
        <span class="c"># This try/except block *must* come before the exitfunc logic.</span>
        <span class="c"># Otherwise, if the registered exitfunc raises an exception the IOLoop</span>
        <span class="c"># will never stop watching self.fd; resulting in an infinite loop of</span>
        <span class="c"># exitfunc.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">remove_handler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fd</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fd</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">):</span>
            <span class="c"># This can happen when the fd is removed by the underlying process</span>
            <span class="c"># before the next cycle of the IOLoop.  Not really a problem.</span>
            <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
        <span class="c"># NOTE: Without this &#39;del&#39; we end up with a memory leak every time</span>
        <span class="c"># a new instance of Multiplex is created.  Apparently the references</span>
        <span class="c"># inside of PeriodicCallback pointing to self prevent proper garbage</span>
        <span class="c"># collection.</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c"># TODO: Make this walk the series from SIGINT to SIGKILL</span>
            <span class="c">#os.kill(self.pid, signal.SIGINT)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">kill</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pid</span><span class="p">,</span> <span class="n">signal</span><span class="o">.</span><span class="n">SIGTERM</span><span class="p">)</span>
            <span class="c">#os.kill(self.pid, signal.SIGKILL)</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="c"># The process is already dead--great.</span>
            <span class="k">pass</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exitstatus</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">pid</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">waitpid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pid</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">pid</span><span class="p">:</span> <span class="c"># pid is 0 if the process is still running</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">exitstatus</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">WEXITSTATUS</span><span class="p">(</span><span class="n">status</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                <span class="c"># This can happen if the program closes itself very quickly</span>
                <span class="c"># immediately after being executed.</span>
                <span class="k">try</span><span class="p">:</span> <span class="c"># Try again with -1</span>
                    <span class="n">pid</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">waitpid</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">WNOHANG</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">pid</span><span class="p">:</span> <span class="c"># pid is 0 if the process is still running</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">exitstatus</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">WEXITSTATUS</span><span class="p">(</span><span class="n">status</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">_</span><span class="p">(</span>
                        <span class="s">&quot;Could not determine exit status for child with &quot;</span>
                        <span class="s">&quot;PID: </span><span class="si">%s</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">pid</span>
                    <span class="p">))</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s">&quot;Setting self.exitstatus to 999&quot;</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">exitstatus</span> <span class="o">=</span> <span class="mi">999</span> <span class="c"># Seems like a good number</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patterns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timeout_check</span><span class="p">(</span><span class="n">timeout_now</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unexpect</span><span class="p">()</span>
        <span class="c"># Call the exitfunc (if set)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exitfunc</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exitfunc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exitstatus</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exitfunc</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="c"># Reset all callbacks so there&#39;s nothing to prevent GC</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span> <span class="o">=</span> <span class="p">{</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">CALLBACK_UPDATE</span><span class="p">:</span> <span class="p">{},</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">CALLBACK_EXIT</span><span class="p">:</span> <span class="p">{},</span>
        <span class="p">}</span>
        <span class="c"># Commented this out so that you can see what was in the terminal</span>
        <span class="c"># emulator after the process terminates.</span>
        <span class="c">#del self.term</span>
        <span class="c"># Kick off a process that finalizes the log (updates metadata and</span>
        <span class="c"># recompresses everything to save disk space)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_path</span><span class="p">:</span>
            <span class="k">return</span> <span class="c"># No log to finalize so we&#39;re done.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">close</span><span class="p">()</span> <span class="c"># Write it out</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">_</span><span class="p">(</span>
            <span class="s">&quot;Finalizing the log for pid </span><span class="si">%s</span><span class="s"> (this can take some time).&quot;</span>
            <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">pid</span>
        <span class="p">))</span>
        <span class="n">PROC</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span>
            <span class="n">target</span><span class="o">=</span><span class="n">get_or_update_metadata</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">log_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">user</span><span class="p">),</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;force_update&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">})</span>
        <span class="n">PROC</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="MultiplexPOSIXIOLoop._ioloop_read_handler"><a class="viewcode-back" href="../Developer/termio.html#termio.MultiplexPOSIXIOLoop._ioloop_read_handler">[docs]</a>    <span class="k">def</span> <span class="nf">_ioloop_read_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read in the output of the process associated with *fd* and write it to</span>
<span class="sd">        `self.term`.</span>

<span class="sd">        :fd: The file descriptor of the child process.</span>
<span class="sd">        :event: An IOLoop event (e.g. IOLoop.READ).</span>

<span class="sd">        .. note:: This method is not meant to be called directly...  The IOLoop should be the one calling it when it detects any given event on the fd.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">event</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">READ</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_call_callback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c"># Child died</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">_</span><span class="p">(</span>
                <span class="s">&quot;Apparently fd </span><span class="si">%s</span><span class="s"> just died (event: </span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fd</span><span class="p">,</span> <span class="n">event</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="MultiplexPOSIXIOLoop._read"><a class="viewcode-back" href="../Developer/termio.html#termio.MultiplexPOSIXIOLoop._read">[docs]</a>    <span class="k">def</span> <span class="nf">_read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">bytes</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads at most *bytes* from the incoming stream, writes the result to</span>
<span class="sd">        the terminal emulator using `term_write`, and returns what was read.</span>
<span class="sd">        If *bytes* is -1 (default) it will read `self.fd` until there&#39;s no more</span>
<span class="sd">        output.</span>

<span class="sd">        Returns the result of all that reading.</span>

<span class="sd">        .. note:: Non-blocking.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Commented out because it can be really noisy.  Uncomment only if you</span>
        <span class="c"># *really* need to debug this method.</span>
        <span class="c">#logging.debug(&quot;MultiplexPOSIXIOLoop._read()&quot;)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">b</span><span class="s">&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">restore_capture_limit</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">capture_limit</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">restore_rate</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fd</span><span class="p">,</span> <span class="s">&#39;rb&#39;</span><span class="p">,</span> <span class="n">closefd</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">buffering</span><span class="o">=</span><span class="mi">1024</span><span class="p">)</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">bytes</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="c"># 2 seconds of blocking is too much.</span>
                    <span class="n">timeout</span> <span class="o">=</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                    <span class="n">loop_start</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctrl_c_pressed</span><span class="p">:</span>
                        <span class="c"># If the user pressed Ctrl-C and the ratelimiter was</span>
                        <span class="c"># engaged then we&#39;d best discard the (possibly huge)</span>
                        <span class="c"># buffer so we don&#39;t waste CPU cyles processing it.</span>
                        <span class="n">discard</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">ctrl_c_pressed</span> <span class="o">=</span> <span class="bp">False</span>
                        <span class="k">return</span> <span class="s">u&#39;^C</span><span class="se">\n</span><span class="s">&#39;</span> <span class="c"># Let the user know what happened</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">restore_rate</span><span class="p">:</span>
                        <span class="c"># Need at least three seconds of inactivity to go back</span>
                        <span class="c"># to unlimited reads</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">remove_timeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">restore_rate</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">restore_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">add_timeout</span><span class="p">(</span>
                            <span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="mi">6</span><span class="p">),</span> <span class="n">restore_capture_limit</span><span class="p">)</span>
                    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                        <span class="n">updated</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">capture_limit</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">updated</span><span class="p">:</span>
                            <span class="k">break</span>
                        <span class="n">result</span> <span class="o">+=</span> <span class="n">updated</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">term_write</span><span class="p">(</span><span class="n">updated</span><span class="p">)</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratelimiter_engaged</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">capture_ratelimiter</span><span class="p">:</span>
                            <span class="k">break</span> <span class="c"># Only allow one read per IOLoop loop</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">capture_limit</span> <span class="o">==</span> <span class="mi">2048</span><span class="p">:</span>
                            <span class="c"># Block for a little while: Enough to keep things</span>
                            <span class="c"># moving but not fast enough to slow everyone else</span>
                            <span class="c"># down</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_blocked_io_handler</span><span class="p">(</span><span class="n">wait</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
                            <span class="k">break</span>
                        <span class="k">if</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">loop_start</span> <span class="o">&gt;</span> <span class="n">timeout</span><span class="p">:</span>
                            <span class="c"># Engage the rate limiter</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">term</span><span class="o">.</span><span class="n">capture</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">capture_ratelimiter</span> <span class="o">=</span> <span class="bp">True</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">capture_limit</span> <span class="o">=</span> <span class="mi">65536</span>
                                <span class="c"># Make sure we eventually get back to defaults:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">add_timeout</span><span class="p">(</span>
                                    <span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="mi">10</span><span class="p">),</span>
                                    <span class="n">restore_capture_limit</span><span class="p">)</span>
                                <span class="c"># NOTE: The capture_ratelimiter doesn&#39;t remove</span>
                                <span class="c"># self.fd from the IOLoop (that&#39;s the diff)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c"># Set the capture limit to a smaller value so</span>
                                <span class="c"># when we re-start output again the noisy</span>
                                <span class="c"># program won&#39;t be able to take over again.</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">capture_limit</span> <span class="o">=</span> <span class="mi">2048</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">restore_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">add_timeout</span><span class="p">(</span>
                                    <span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="mi">6</span><span class="p">),</span>
                                    <span class="n">restore_capture_limit</span><span class="p">)</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_blocked_io_handler</span><span class="p">()</span>
                            <span class="k">break</span>
                <span class="k">elif</span> <span class="nb">bytes</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">term_write</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c"># IOErrors can happen when self.fd is closed before we finish</span>
            <span class="c"># reading from it.  Not a big deal.</span>
            <span class="k">pass</span>
        <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;Got exception in read: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="sb">`e`</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">traceback</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s">&quot;Got unhandled exception in read (???): </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="sb">`e`</span><span class="p">)</span>
            <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">(</span><span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isalive</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
</div>
<div class="viewcode-block" id="MultiplexPOSIXIOLoop._timeout_checker"><a class="viewcode-back" href="../Developer/termio.html#termio.MultiplexPOSIXIOLoop._timeout_checker">[docs]</a>    <span class="k">def</span> <span class="nf">_timeout_checker</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Runs `timeout_check` and if there are no more non-sticky</span>
<span class="sd">        patterns in :attr:`self._patterns`, stops :attr:`scheduler`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_checking_patterns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_checking_patterns</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">remaining_patterns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout_check</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">remaining_patterns</span><span class="p">:</span>
                <span class="c"># No reason to keep the PeriodicCallback going</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Stopping self.scheduler (no remaining patterns)&quot;</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="c"># Now this is a neat trick:  The way IOLoop works with its</span>
                <span class="c"># stack_context thingamabob the scheduler doesn&#39;t actualy end up</span>
                <span class="c"># inside the MultiplexPOSIXIOLoop instance inside of this</span>
                <span class="c"># instance of _timeout_checker() *except* inside the main</span>
                <span class="c"># thread.  It is absolutely wacky but it works and works well :)</span>
                    <span class="k">pass</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_checking_patterns</span> <span class="o">=</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="MultiplexPOSIXIOLoop.read"><a class="viewcode-back" href="../Developer/termio.html#termio.MultiplexPOSIXIOLoop.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">bytes</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. note:: This is an override of `BaseMultiplex.read` in order to take advantage of the IOLoop for ensuring `BaseMultiplex.expect` patterns timeout properly.</span>

<span class="sd">        Calls `_read` and checks if any timeouts have been reached</span>
<span class="sd">        in :attr:`self._patterns`.  Returns the result of :meth:`_read`.  This</span>
<span class="sd">        is an override of `BaseMultiplex.read` that will create a</span>
<span class="sd">        :class:`tornado.ioloop.PeriodicCallback` (as `self.scheduler`) that</span>
<span class="sd">        executes :attr:`timeout_check` at a regular interval.  The</span>
<span class="sd">        `PeriodicCallback` will automatically cancel itself if there are no more</span>
<span class="sd">        non-sticky patterns in :attr:`self._patterns`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># 50ms basic output rate limit on everything</span>
        <span class="n">rate_wait</span> <span class="o">=</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">milliseconds</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_timeout</span> <span class="o">&gt;</span> <span class="n">rate_wait</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_timeout</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
            <span class="n">remaining_patterns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout_check</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">remaining_patterns</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">_running</span><span class="p">:</span>
                <span class="c"># Start &#39;er up in case we don&#39;t get any more output</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Starting self.scheduler to check for timeouts&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scheduler</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">isalive</span><span class="p">()</span> <span class="c"># This just ensures the exitfunc is called (if necessary)</span>
            <span class="k">return</span> <span class="n">result</span>
</div>
<div class="viewcode-block" id="MultiplexPOSIXIOLoop._write"><a class="viewcode-back" href="../Developer/termio.html#termio.MultiplexPOSIXIOLoop._write">[docs]</a>    <span class="k">def</span> <span class="nf">_write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chars</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes *chars* to `self.fd` (pretty straightforward).  If IOError or</span>
<span class="sd">        OSError exceptions are encountered, will run `terminate`.  All other</span>
<span class="sd">        exceptions are logged but no action will be taken.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#logging.debug(&quot;MultiplexPOSIXIOLoop._write(%s)&quot; % repr(chars))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fd</span><span class="p">,</span> <span class="s">&#39;wt&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s">&#39;UTF-8&#39;</span><span class="p">,</span> <span class="n">closefd</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="k">as</span> <span class="n">writer</span><span class="p">:</span>
                    <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratelimiter_engaged</span><span class="p">:</span>
                <span class="k">if</span> <span class="s">u&#39;</span><span class="se">\x03</span><span class="s">&#39;</span> <span class="ow">in</span> <span class="n">chars</span><span class="p">:</span> <span class="c"># Ctrl-C</span>
                    <span class="c"># This will force self._read() to discard the buffer</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ctrl_c_pressed</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="c"># Reattach the fd so the user can continue immediately</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_reenable_output</span><span class="p">()</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">IOError</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">isalive</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;write() exception: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">e</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="MultiplexPOSIXIOLoop.write"><a class="viewcode-back" href="../Developer/termio.html#termio.MultiplexPOSIXIOLoop.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chars</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calls `_write(*chars*)` via `_call_callback` to ensure thread safety.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">isalive</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">ProgramTerminated</span><span class="p">(</span><span class="n">_</span><span class="p">(</span><span class="s">&quot;Child process is not running.&quot;</span><span class="p">))</span>
        <span class="n">write</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">,</span> <span class="n">chars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call_callback</span><span class="p">(</span><span class="n">write</span><span class="p">)</span>

<span class="c"># Here&#39;s an example of how termio compares to pexpect:</span>
<span class="c">#import pexpect</span>
<span class="c">#child = pexpect.spawn (&#39;ftp ftp.openbsd.org&#39;)</span>
<span class="c">#child.expect (&#39;Name .*: &#39;)</span>
<span class="c">#child.sendline (&#39;anonymous&#39;)</span>
<span class="c">#child.expect (&#39;Password:&#39;)</span>
<span class="c">#child.sendline (&#39;noah@example.com&#39;)</span>
<span class="c">#child.expect (&#39;ftp&gt; &#39;)</span>
<span class="c">#child.sendline (&#39;cd pub&#39;)</span>
<span class="c">#child.expect(&#39;ftp&gt; &#39;)</span>
<span class="c">#child.sendline (&#39;get ls-lR.gz&#39;)</span>
<span class="c">#child.expect(&#39;ftp&gt; &#39;)</span>
<span class="c">#child.sendline (&#39;bye&#39;)</span>
<span class="c"># NOTE: Every expect() in the above example is a blocking call.</span>

<span class="c"># This is the same thing, rewritten using termio:</span>
<span class="c">#import termio</span>
<span class="c">#child = termio.Multiplex(&#39;ftp ftp.openbsd.org&#39;, debug=True)</span>
<span class="c">## Expectations come first</span>
<span class="c">#child.expect(&#39;Name .*:&#39;, &quot;anonymous\n&quot;)</span>
<span class="c">#child.expect(&#39;Password:&#39;, &#39;user@company.com\n&#39;)</span>
<span class="c">#child.expect(&#39;ftp&gt;$&#39;, &#39;cd pub\n&#39;)</span>
<span class="c">#child.expect(&#39;ftp&gt;$&#39;, &#39;get ls-lR.gz\n&#39;)</span>
<span class="c">#child.expect(&#39;ftp&gt;$&#39;, &#39;bye\n&#39;)</span>
<span class="c">#child.await() # Blocks until all patterns have been matched or a timeout</span>
<span class="c"># NOTE: If this code were called inside of an already-started IOLoop there would</span>
<span class="c"># be no need to call await(). Everything would be asynchronous and non-blocking.</span>
</div></div>
<div class="viewcode-block" id="spawn"><a class="viewcode-back" href="../Developer/termio.html#termio.spawn">[docs]</a><span class="k">def</span> <span class="nf">spawn</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="mi">24</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">em_dimensions</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A shortcut to::</span>

<span class="sd">        &gt;&gt;&gt; m = Multiplex(cmd, *args, **kwargs)</span>
<span class="sd">        &gt;&gt;&gt; m.spawn(rows, cols, env)</span>
<span class="sd">        &gt;&gt;&gt; return m</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">Multiplex</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">m</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">em_dimensions</span><span class="o">=</span><span class="n">em_dimensions</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">m</span>
</div>
<div class="viewcode-block" id="getstatusoutput"><a class="viewcode-back" href="../Developer/termio.html#termio.getstatusoutput">[docs]</a><span class="k">def</span> <span class="nf">getstatusoutput</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Emulates Python&#39;s commands.getstatusoutput() function using a Multiplex</span>
<span class="sd">    instance.</span>

<span class="sd">    Optionally, any additional keyword arguments (\*\*kwargs) provided will be</span>
<span class="sd">    passed to the spawn() command.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># NOTE: This function is primarily here to provide an example of how to use</span>
    <span class="c"># termio.Multiplex instances in a traditional, blocking manner.</span>
    <span class="n">output</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">Multiplex</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>
    <span class="n">m</span><span class="o">.</span><span class="n">spawn</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">m</span><span class="o">.</span><span class="n">isalive</span><span class="p">():</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">+=</span> <span class="n">result</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span> <span class="c"># Reduce CPU overhead</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">exitstatus</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
</div>
<span class="k">if</span> <span class="n">POSIX</span><span class="p">:</span>
    <span class="n">Multiplex</span> <span class="o">=</span> <span class="n">MultiplexPOSIXIOLoop</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">_</span><span class="p">(</span>
        <span class="s">&quot;termio currently only works on Unix platforms.&quot;</span><span class="p">))</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/ls_logo_1inch_300dpi.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">Gate One Documentation</a> &raquo;</li>
          <li><a href="index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>

    <div class="footer">
        &copy; Copyright 2011, Liftoff Software Corporation.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
<script type="text/javascript">
window.onload = function(e) {
    // Make our collapseindex elements actually collapsible
    $('<span class="collapsindextitle">Index</span> <a class="showhide">[show]</a>').insertBefore('.collapseindex');
    $('.showhide').each(function(index, value){
        var showHide = $(this);
        showHide.click(function() {
            if (this.innerHTML == "[hide]") {
                this.innerHTML = "[show]";
            } else {
                this.innerHTML = "[hide]";
            }
            $(this).next('.collapseindex').toggle(1); // This should always be the next .collapseindex element
        });
    });
    $('.collapseindex').each(function(index, value){
        // Start them out hidden
        $(this).hide();
    });
}
</script>

  </body>
</html>